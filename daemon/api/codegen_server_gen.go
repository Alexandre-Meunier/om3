// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /auth/token)
	PostAuthToken(w http.ResponseWriter, r *http.Request, params PostAuthTokenParams)

	// (GET /daemon/dns/dump)
	GetDaemonDNSDump(w http.ResponseWriter, r *http.Request)

	// (GET /daemon/events)
	GetDaemonEvents(w http.ResponseWriter, r *http.Request, params GetDaemonEventsParams)

	// (POST /daemon/join)
	PostDaemonJoin(w http.ResponseWriter, r *http.Request, params PostDaemonJoinParams)

	// (POST /daemon/leave)
	PostDaemonLeave(w http.ResponseWriter, r *http.Request, params PostDaemonLeaveParams)

	// (POST /daemon/logs/control)
	PostDaemonLogsControl(w http.ResponseWriter, r *http.Request)

	// (GET /daemon/running)
	GetDaemonRunning(w http.ResponseWriter, r *http.Request)

	// (GET /daemon/status)
	GetDaemonStatus(w http.ResponseWriter, r *http.Request, params GetDaemonStatusParams)

	// (POST /daemon/stop)
	PostDaemonStop(w http.ResponseWriter, r *http.Request)

	// (POST /daemon/sub/action)
	PostDaemonSubAction(w http.ResponseWriter, r *http.Request)

	// (POST /instance/status)
	PostInstanceStatus(w http.ResponseWriter, r *http.Request)

	// (POST /node/clear)
	PostNodeClear(w http.ResponseWriter, r *http.Request)

	// (GET /node/file)
	GetNodeFile(w http.ResponseWriter, r *http.Request, params GetNodeFileParams)

	// (POST /node/file)
	PostNodeFile(w http.ResponseWriter, r *http.Request, params PostNodeFileParams)

	// (POST /node/monitor)
	PostNodeMonitor(w http.ResponseWriter, r *http.Request)

	// (GET /nodes/info)
	GetNodesInfo(w http.ResponseWriter, r *http.Request)

	// (POST /object/abort)
	PostObjectAbort(w http.ResponseWriter, r *http.Request)

	// (POST /object/clear)
	PostObjectClear(w http.ResponseWriter, r *http.Request)

	// (GET /object/config)
	GetObjectConfig(w http.ResponseWriter, r *http.Request, params GetObjectConfigParams)

	// (GET /object/file)
	GetObjectFile(w http.ResponseWriter, r *http.Request, params GetObjectFileParams)

	// (POST /object/monitor)
	PostObjectMonitor(w http.ResponseWriter, r *http.Request)

	// (POST /object/progress)
	PostObjectProgress(w http.ResponseWriter, r *http.Request)

	// (GET /object/selector)
	GetObjectSelector(w http.ResponseWriter, r *http.Request, params GetObjectSelectorParams)

	// (POST /object/switchTo)
	PostObjectSwitchTo(w http.ResponseWriter, r *http.Request)

	// (GET /public/openapi)
	GetSwagger(w http.ResponseWriter, r *http.Request)

	// (GET /relay/message)
	GetRelayMessage(w http.ResponseWriter, r *http.Request, params GetRelayMessageParams)

	// (POST /relay/message)
	PostRelayMessage(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// PostAuthToken operation middleware
func (siw *ServerInterfaceWrapper) PostAuthToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthTokenParams

	// ------------- Optional query parameter "role" -------------
	if paramValue := r.URL.Query().Get("role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "role", r.URL.Query(), &params.Role)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "role", Err: err})
		return
	}

	// ------------- Optional query parameter "duration" -------------
	if paramValue := r.URL.Query().Get("duration"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "duration", r.URL.Query(), &params.Duration)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "duration", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthToken(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetDaemonDNSDump operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonDNSDump(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonDNSDump(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetDaemonEvents operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDaemonEventsParams

	// ------------- Optional query parameter "duration" -------------
	if paramValue := r.URL.Query().Get("duration"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "duration", r.URL.Query(), &params.Duration)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "duration", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "filter" -------------
	if paramValue := r.URL.Query().Get("filter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "filter", r.URL.Query(), &params.Filter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonEvents(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostDaemonJoin operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonJoin(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDaemonJoinParams

	// ------------- Required query parameter "node" -------------
	if paramValue := r.URL.Query().Get("node"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "node"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "node", r.URL.Query(), &params.Node)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonJoin(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostDaemonLeave operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonLeave(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDaemonLeaveParams

	// ------------- Required query parameter "node" -------------
	if paramValue := r.URL.Query().Get("node"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "node"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "node", r.URL.Query(), &params.Node)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonLeave(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostDaemonLogsControl operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonLogsControl(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonLogsControl(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetDaemonRunning operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonRunning(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonRunning(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetDaemonStatus operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDaemonStatusParams

	// ------------- Optional query parameter "namespace" -------------
	if paramValue := r.URL.Query().Get("namespace"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "namespace", r.URL.Query(), &params.Namespace)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Optional query parameter "relatives" -------------
	if paramValue := r.URL.Query().Get("relatives"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "relatives", r.URL.Query(), &params.Relatives)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relatives", Err: err})
		return
	}

	// ------------- Optional query parameter "selector" -------------
	if paramValue := r.URL.Query().Get("selector"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "selector", r.URL.Query(), &params.Selector)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selector", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonStatus(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostDaemonStop operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonStop(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonStop(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostDaemonSubAction operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonSubAction(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonSubAction(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostInstanceStatus operation middleware
func (siw *ServerInterfaceWrapper) PostInstanceStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostInstanceStatus(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostNodeClear operation middleware
func (siw *ServerInterfaceWrapper) PostNodeClear(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostNodeClear(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetNodeFile operation middleware
func (siw *ServerInterfaceWrapper) GetNodeFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNodeFileParams

	// ------------- Required query parameter "kind" -------------
	if paramValue := r.URL.Query().Get("kind"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "kind"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "kind", r.URL.Query(), &params.Kind)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	// ------------- Required query parameter "name" -------------
	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodeFile(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostNodeFile operation middleware
func (siw *ServerInterfaceWrapper) PostNodeFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostNodeFileParams

	// ------------- Required query parameter "kind" -------------
	if paramValue := r.URL.Query().Get("kind"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "kind"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "kind", r.URL.Query(), &params.Kind)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	// ------------- Required query parameter "name" -------------
	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostNodeFile(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostNodeMonitor operation middleware
func (siw *ServerInterfaceWrapper) PostNodeMonitor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostNodeMonitor(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetNodesInfo operation middleware
func (siw *ServerInterfaceWrapper) GetNodesInfo(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodesInfo(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostObjectAbort operation middleware
func (siw *ServerInterfaceWrapper) PostObjectAbort(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectAbort(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostObjectClear operation middleware
func (siw *ServerInterfaceWrapper) PostObjectClear(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectClear(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetObjectConfig operation middleware
func (siw *ServerInterfaceWrapper) GetObjectConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectConfigParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	// ------------- Optional query parameter "evaluate" -------------
	if paramValue := r.URL.Query().Get("evaluate"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "evaluate", r.URL.Query(), &params.Evaluate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "evaluate", Err: err})
		return
	}

	// ------------- Optional query parameter "impersonate" -------------
	if paramValue := r.URL.Query().Get("impersonate"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "impersonate", r.URL.Query(), &params.Impersonate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "impersonate", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObjectConfig(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetObjectFile operation middleware
func (siw *ServerInterfaceWrapper) GetObjectFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectFileParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObjectFile(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostObjectMonitor operation middleware
func (siw *ServerInterfaceWrapper) PostObjectMonitor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectMonitor(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostObjectProgress operation middleware
func (siw *ServerInterfaceWrapper) PostObjectProgress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectProgress(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetObjectSelector operation middleware
func (siw *ServerInterfaceWrapper) GetObjectSelector(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectSelectorParams

	// ------------- Required query parameter "selector" -------------
	if paramValue := r.URL.Query().Get("selector"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "selector"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "selector", r.URL.Query(), &params.Selector)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selector", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObjectSelector(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostObjectSwitchTo operation middleware
func (siw *ServerInterfaceWrapper) PostObjectSwitchTo(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectSwitchTo(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetSwagger operation middleware
func (siw *ServerInterfaceWrapper) GetSwagger(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSwagger(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRelayMessage operation middleware
func (siw *ServerInterfaceWrapper) GetRelayMessage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRelayMessageParams

	// ------------- Optional query parameter "nodename" -------------
	if paramValue := r.URL.Query().Get("nodename"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nodename", r.URL.Query(), &params.Nodename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nodename", Err: err})
		return
	}

	// ------------- Optional query parameter "cluster_id" -------------
	if paramValue := r.URL.Query().Get("cluster_id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "cluster_id", r.URL.Query(), &params.ClusterId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster_id", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRelayMessage(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostRelayMessage operation middleware
func (siw *ServerInterfaceWrapper) PostRelayMessage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostRelayMessage(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token", wrapper.PostAuthToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/dns/dump", wrapper.GetDaemonDNSDump)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/events", wrapper.GetDaemonEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/join", wrapper.PostDaemonJoin)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/leave", wrapper.PostDaemonLeave)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/logs/control", wrapper.PostDaemonLogsControl)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/running", wrapper.GetDaemonRunning)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/status", wrapper.GetDaemonStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/stop", wrapper.PostDaemonStop)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/sub/action", wrapper.PostDaemonSubAction)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/instance/status", wrapper.PostInstanceStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/node/clear", wrapper.PostNodeClear)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/node/file", wrapper.GetNodeFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/node/file", wrapper.PostNodeFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/node/monitor", wrapper.PostNodeMonitor)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/nodes/info", wrapper.GetNodesInfo)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/abort", wrapper.PostObjectAbort)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/clear", wrapper.PostObjectClear)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/object/config", wrapper.GetObjectConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/object/file", wrapper.GetObjectFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/monitor", wrapper.PostObjectMonitor)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/progress", wrapper.PostObjectProgress)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/object/selector", wrapper.GetObjectSelector)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/switchTo", wrapper.PostObjectSwitchTo)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/public/openapi", wrapper.GetSwagger)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/relay/message", wrapper.GetRelayMessage)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/relay/message", wrapper.PostRelayMessage)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"fDJjw6W6OH92/iK7v7n//wAAAP//TmAplzVoAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
