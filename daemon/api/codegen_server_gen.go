// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /auth/token)
	PostAuthToken(w http.ResponseWriter, r *http.Request, params PostAuthTokenParams)

	// (GET /daemon/dns/dump)
	GetDaemonDNSDump(w http.ResponseWriter, r *http.Request)

	// (GET /daemon/events)
	GetDaemonEvents(w http.ResponseWriter, r *http.Request, params GetDaemonEventsParams)

	// (POST /daemon/join)
	PostDaemonJoin(w http.ResponseWriter, r *http.Request, params PostDaemonJoinParams)

	// (POST /daemon/leave)
	PostDaemonLeave(w http.ResponseWriter, r *http.Request, params PostDaemonLeaveParams)

	// (POST /daemon/logs/control)
	PostDaemonLogsControl(w http.ResponseWriter, r *http.Request)

	// (GET /daemon/running)
	GetDaemonRunning(w http.ResponseWriter, r *http.Request)

	// (GET /daemon/status)
	GetDaemonStatus(w http.ResponseWriter, r *http.Request, params GetDaemonStatusParams)

	// (POST /daemon/stop)
	PostDaemonStop(w http.ResponseWriter, r *http.Request)

	// (POST /daemon/sub/action)
	PostDaemonSubAction(w http.ResponseWriter, r *http.Request)

	// (POST /instance/status)
	PostInstanceStatus(w http.ResponseWriter, r *http.Request)

	// (GET /networks)
	GetNetworks(w http.ResponseWriter, r *http.Request, params GetNetworksParams)

	// (POST /node/clear)
	PostNodeClear(w http.ResponseWriter, r *http.Request)

	// (GET /node/drbd/allocation)
	GetNodeDRBDAllocation(w http.ResponseWriter, r *http.Request)

	// (GET /node/drbd/config)
	GetNodeDRBDConfig(w http.ResponseWriter, r *http.Request, params GetNodeDRBDConfigParams)

	// (POST /node/drbd/config)
	PostNodeDRBDConfig(w http.ResponseWriter, r *http.Request, params PostNodeDRBDConfigParams)

	// (POST /node/monitor)
	PostNodeMonitor(w http.ResponseWriter, r *http.Request)

	// (GET /nodes/info)
	GetNodesInfo(w http.ResponseWriter, r *http.Request)

	// (POST /object/abort)
	PostObjectAbort(w http.ResponseWriter, r *http.Request)

	// (POST /object/clear)
	PostObjectClear(w http.ResponseWriter, r *http.Request)

	// (GET /object/config)
	GetObjectConfig(w http.ResponseWriter, r *http.Request, params GetObjectConfigParams)

	// (GET /object/file)
	GetObjectFile(w http.ResponseWriter, r *http.Request, params GetObjectFileParams)

	// (POST /object/monitor)
	PostObjectMonitor(w http.ResponseWriter, r *http.Request)

	// (POST /object/progress)
	PostObjectProgress(w http.ResponseWriter, r *http.Request)

	// (GET /object/selector)
	GetObjectSelector(w http.ResponseWriter, r *http.Request, params GetObjectSelectorParams)

	// (POST /object/switchTo)
	PostObjectSwitchTo(w http.ResponseWriter, r *http.Request)

	// (GET /public/openapi)
	GetSwagger(w http.ResponseWriter, r *http.Request)

	// (GET /relay/message)
	GetRelayMessage(w http.ResponseWriter, r *http.Request, params GetRelayMessageParams)

	// (POST /relay/message)
	PostRelayMessage(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PostAuthToken operation middleware
func (siw *ServerInterfaceWrapper) PostAuthToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthTokenParams

	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", r.URL.Query(), &params.Role)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "role", Err: err})
		return
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", r.URL.Query(), &params.Duration)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "duration", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthToken(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetDaemonDNSDump operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonDNSDump(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonDNSDump(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetDaemonEvents operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDaemonEventsParams

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", r.URL.Query(), &params.Duration)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "duration", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", r.URL.Query(), &params.Filter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonEvents(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostDaemonJoin operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonJoin(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDaemonJoinParams

	// ------------- Required query parameter "node" -------------

	if paramValue := r.URL.Query().Get("node"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "node"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "node", r.URL.Query(), &params.Node)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonJoin(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostDaemonLeave operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonLeave(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDaemonLeaveParams

	// ------------- Required query parameter "node" -------------

	if paramValue := r.URL.Query().Get("node"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "node"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "node", r.URL.Query(), &params.Node)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonLeave(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostDaemonLogsControl operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonLogsControl(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonLogsControl(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetDaemonRunning operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonRunning(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonRunning(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetDaemonStatus operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDaemonStatusParams

	// ------------- Optional query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace", r.URL.Query(), &params.Namespace)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Optional query parameter "relatives" -------------

	err = runtime.BindQueryParameter("form", true, false, "relatives", r.URL.Query(), &params.Relatives)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relatives", Err: err})
		return
	}

	// ------------- Optional query parameter "selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "selector", r.URL.Query(), &params.Selector)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selector", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonStatus(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostDaemonStop operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonStop(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonStop(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostDaemonSubAction operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonSubAction(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonSubAction(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostInstanceStatus operation middleware
func (siw *ServerInterfaceWrapper) PostInstanceStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostInstanceStatus(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetNetworks operation middleware
func (siw *ServerInterfaceWrapper) GetNetworks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNetworksParams

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNetworks(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostNodeClear operation middleware
func (siw *ServerInterfaceWrapper) PostNodeClear(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostNodeClear(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetNodeDRBDAllocation operation middleware
func (siw *ServerInterfaceWrapper) GetNodeDRBDAllocation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodeDRBDAllocation(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetNodeDRBDConfig operation middleware
func (siw *ServerInterfaceWrapper) GetNodeDRBDConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNodeDRBDConfigParams

	// ------------- Required query parameter "name" -------------

	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodeDRBDConfig(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostNodeDRBDConfig operation middleware
func (siw *ServerInterfaceWrapper) PostNodeDRBDConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostNodeDRBDConfigParams

	// ------------- Required query parameter "name" -------------

	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostNodeDRBDConfig(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostNodeMonitor operation middleware
func (siw *ServerInterfaceWrapper) PostNodeMonitor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostNodeMonitor(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetNodesInfo operation middleware
func (siw *ServerInterfaceWrapper) GetNodesInfo(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodesInfo(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostObjectAbort operation middleware
func (siw *ServerInterfaceWrapper) PostObjectAbort(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectAbort(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostObjectClear operation middleware
func (siw *ServerInterfaceWrapper) PostObjectClear(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectClear(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetObjectConfig operation middleware
func (siw *ServerInterfaceWrapper) GetObjectConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectConfigParams

	// ------------- Required query parameter "path" -------------

	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	// ------------- Optional query parameter "evaluate" -------------

	err = runtime.BindQueryParameter("form", true, false, "evaluate", r.URL.Query(), &params.Evaluate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "evaluate", Err: err})
		return
	}

	// ------------- Optional query parameter "impersonate" -------------

	err = runtime.BindQueryParameter("form", true, false, "impersonate", r.URL.Query(), &params.Impersonate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "impersonate", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObjectConfig(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetObjectFile operation middleware
func (siw *ServerInterfaceWrapper) GetObjectFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectFileParams

	// ------------- Required query parameter "path" -------------

	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObjectFile(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostObjectMonitor operation middleware
func (siw *ServerInterfaceWrapper) PostObjectMonitor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectMonitor(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostObjectProgress operation middleware
func (siw *ServerInterfaceWrapper) PostObjectProgress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectProgress(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetObjectSelector operation middleware
func (siw *ServerInterfaceWrapper) GetObjectSelector(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectSelectorParams

	// ------------- Required query parameter "selector" -------------

	if paramValue := r.URL.Query().Get("selector"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "selector"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "selector", r.URL.Query(), &params.Selector)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selector", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObjectSelector(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostObjectSwitchTo operation middleware
func (siw *ServerInterfaceWrapper) PostObjectSwitchTo(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectSwitchTo(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSwagger operation middleware
func (siw *ServerInterfaceWrapper) GetSwagger(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSwagger(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRelayMessage operation middleware
func (siw *ServerInterfaceWrapper) GetRelayMessage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRelayMessageParams

	// ------------- Optional query parameter "nodename" -------------

	err = runtime.BindQueryParameter("form", true, false, "nodename", r.URL.Query(), &params.Nodename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nodename", Err: err})
		return
	}

	// ------------- Optional query parameter "cluster_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "cluster_id", r.URL.Query(), &params.ClusterId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster_id", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRelayMessage(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostRelayMessage operation middleware
func (siw *ServerInterfaceWrapper) PostRelayMessage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostRelayMessage(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshallingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshallingParamError) Error() string {
	return fmt.Sprintf("Error unmarshalling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshallingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token", wrapper.PostAuthToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/dns/dump", wrapper.GetDaemonDNSDump)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/events", wrapper.GetDaemonEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/join", wrapper.PostDaemonJoin)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/leave", wrapper.PostDaemonLeave)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/logs/control", wrapper.PostDaemonLogsControl)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/running", wrapper.GetDaemonRunning)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/status", wrapper.GetDaemonStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/stop", wrapper.PostDaemonStop)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/sub/action", wrapper.PostDaemonSubAction)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/instance/status", wrapper.PostInstanceStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/networks", wrapper.GetNetworks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/node/clear", wrapper.PostNodeClear)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/node/drbd/allocation", wrapper.GetNodeDRBDAllocation)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/node/drbd/config", wrapper.GetNodeDRBDConfig)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/node/drbd/config", wrapper.PostNodeDRBDConfig)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/node/monitor", wrapper.PostNodeMonitor)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/nodes/info", wrapper.GetNodesInfo)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/abort", wrapper.PostObjectAbort)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/clear", wrapper.PostObjectClear)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/object/config", wrapper.GetObjectConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/object/file", wrapper.GetObjectFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/monitor", wrapper.PostObjectMonitor)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/progress", wrapper.PostObjectProgress)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/object/selector", wrapper.GetObjectSelector)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/switchTo", wrapper.PostObjectSwitchTo)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/public/openapi", wrapper.GetSwagger)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/relay/message", wrapper.GetRelayMessage)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/relay/message", wrapper.PostRelayMessage)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//3Dl+/lqgAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
