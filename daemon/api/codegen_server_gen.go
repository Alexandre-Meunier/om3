// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /auth/token)
	PostAuthToken(w http.ResponseWriter, r *http.Request, params PostAuthTokenParams)

	// (GET /daemon/dns/dump)
	GetDaemonDNSDump(w http.ResponseWriter, r *http.Request)

	// (GET /daemon/events)
	GetDaemonEvents(w http.ResponseWriter, r *http.Request, params GetDaemonEventsParams)

	// (POST /daemon/join)
	PostDaemonJoin(w http.ResponseWriter, r *http.Request, params PostDaemonJoinParams)

	// (POST /daemon/leave)
	PostDaemonLeave(w http.ResponseWriter, r *http.Request, params PostDaemonLeaveParams)

	// (POST /daemon/logs/control)
	PostDaemonLogsControl(w http.ResponseWriter, r *http.Request)

	// (GET /daemon/running)
	GetDaemonRunning(w http.ResponseWriter, r *http.Request)

	// (GET /daemon/status)
	GetDaemonStatus(w http.ResponseWriter, r *http.Request, params GetDaemonStatusParams)

	// (POST /daemon/stop)
	PostDaemonStop(w http.ResponseWriter, r *http.Request)

	// (POST /daemon/sub/action)
	PostDaemonSubAction(w http.ResponseWriter, r *http.Request)

	// (POST /instance/status)
	PostInstanceStatus(w http.ResponseWriter, r *http.Request)

	// (GET /networks)
	GetNetworks(w http.ResponseWriter, r *http.Request, params GetNetworksParams)

	// (POST /node/clear)
	PostNodeClear(w http.ResponseWriter, r *http.Request)

	// (GET /node/drbd/allocation)
	GetNodeDRBDAllocation(w http.ResponseWriter, r *http.Request)

	// (GET /node/drbd/config)
	GetNodeDRBDConfig(w http.ResponseWriter, r *http.Request, params GetNodeDRBDConfigParams)

	// (POST /node/drbd/config)
	PostNodeDRBDConfig(w http.ResponseWriter, r *http.Request, params PostNodeDRBDConfigParams)

	// (POST /node/monitor)
	PostNodeMonitor(w http.ResponseWriter, r *http.Request)

	// (GET /nodes/info)
	GetNodesInfo(w http.ResponseWriter, r *http.Request)

	// (POST /object/abort)
	PostObjectAbort(w http.ResponseWriter, r *http.Request)

	// (POST /object/clear)
	PostObjectClear(w http.ResponseWriter, r *http.Request)

	// (GET /object/config)
	GetObjectConfig(w http.ResponseWriter, r *http.Request, params GetObjectConfigParams)

	// (GET /object/file)
	GetObjectFile(w http.ResponseWriter, r *http.Request, params GetObjectFileParams)

	// (POST /object/monitor)
	PostObjectMonitor(w http.ResponseWriter, r *http.Request)

	// (POST /object/progress)
	PostObjectProgress(w http.ResponseWriter, r *http.Request)

	// (GET /object/selector)
	GetObjectSelector(w http.ResponseWriter, r *http.Request, params GetObjectSelectorParams)

	// (POST /object/switchTo)
	PostObjectSwitchTo(w http.ResponseWriter, r *http.Request)

	// (GET /pools)
	GetPools(w http.ResponseWriter, r *http.Request, params GetPoolsParams)

	// (GET /public/openapi)
	GetSwagger(w http.ResponseWriter, r *http.Request)

	// (GET /relay/message)
	GetRelayMessage(w http.ResponseWriter, r *http.Request, params GetRelayMessageParams)

	// (POST /relay/message)
	PostRelayMessage(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PostAuthToken operation middleware
func (siw *ServerInterfaceWrapper) PostAuthToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthTokenParams

	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", r.URL.Query(), &params.Role)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "role", Err: err})
		return
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", r.URL.Query(), &params.Duration)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "duration", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthToken(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetDaemonDNSDump operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonDNSDump(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonDNSDump(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetDaemonEvents operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDaemonEventsParams

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", r.URL.Query(), &params.Duration)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "duration", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", r.URL.Query(), &params.Filter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonEvents(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostDaemonJoin operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonJoin(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDaemonJoinParams

	// ------------- Required query parameter "node" -------------

	if paramValue := r.URL.Query().Get("node"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "node"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "node", r.URL.Query(), &params.Node)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonJoin(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostDaemonLeave operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonLeave(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDaemonLeaveParams

	// ------------- Required query parameter "node" -------------

	if paramValue := r.URL.Query().Get("node"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "node"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "node", r.URL.Query(), &params.Node)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonLeave(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostDaemonLogsControl operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonLogsControl(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonLogsControl(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetDaemonRunning operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonRunning(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonRunning(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetDaemonStatus operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDaemonStatusParams

	// ------------- Optional query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace", r.URL.Query(), &params.Namespace)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Optional query parameter "relatives" -------------

	err = runtime.BindQueryParameter("form", true, false, "relatives", r.URL.Query(), &params.Relatives)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relatives", Err: err})
		return
	}

	// ------------- Optional query parameter "selector" -------------

	err = runtime.BindQueryParameter("form", true, false, "selector", r.URL.Query(), &params.Selector)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selector", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonStatus(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostDaemonStop operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonStop(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonStop(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostDaemonSubAction operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonSubAction(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonSubAction(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostInstanceStatus operation middleware
func (siw *ServerInterfaceWrapper) PostInstanceStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostInstanceStatus(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetNetworks operation middleware
func (siw *ServerInterfaceWrapper) GetNetworks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNetworksParams

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNetworks(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostNodeClear operation middleware
func (siw *ServerInterfaceWrapper) PostNodeClear(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostNodeClear(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetNodeDRBDAllocation operation middleware
func (siw *ServerInterfaceWrapper) GetNodeDRBDAllocation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodeDRBDAllocation(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetNodeDRBDConfig operation middleware
func (siw *ServerInterfaceWrapper) GetNodeDRBDConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNodeDRBDConfigParams

	// ------------- Required query parameter "name" -------------

	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodeDRBDConfig(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostNodeDRBDConfig operation middleware
func (siw *ServerInterfaceWrapper) PostNodeDRBDConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostNodeDRBDConfigParams

	// ------------- Required query parameter "name" -------------

	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostNodeDRBDConfig(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostNodeMonitor operation middleware
func (siw *ServerInterfaceWrapper) PostNodeMonitor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostNodeMonitor(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetNodesInfo operation middleware
func (siw *ServerInterfaceWrapper) GetNodesInfo(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodesInfo(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostObjectAbort operation middleware
func (siw *ServerInterfaceWrapper) PostObjectAbort(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectAbort(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostObjectClear operation middleware
func (siw *ServerInterfaceWrapper) PostObjectClear(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectClear(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetObjectConfig operation middleware
func (siw *ServerInterfaceWrapper) GetObjectConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectConfigParams

	// ------------- Required query parameter "path" -------------

	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	// ------------- Optional query parameter "evaluate" -------------

	err = runtime.BindQueryParameter("form", true, false, "evaluate", r.URL.Query(), &params.Evaluate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "evaluate", Err: err})
		return
	}

	// ------------- Optional query parameter "impersonate" -------------

	err = runtime.BindQueryParameter("form", true, false, "impersonate", r.URL.Query(), &params.Impersonate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "impersonate", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObjectConfig(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetObjectFile operation middleware
func (siw *ServerInterfaceWrapper) GetObjectFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectFileParams

	// ------------- Required query parameter "path" -------------

	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObjectFile(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostObjectMonitor operation middleware
func (siw *ServerInterfaceWrapper) PostObjectMonitor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectMonitor(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostObjectProgress operation middleware
func (siw *ServerInterfaceWrapper) PostObjectProgress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectProgress(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetObjectSelector operation middleware
func (siw *ServerInterfaceWrapper) GetObjectSelector(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectSelectorParams

	// ------------- Required query parameter "selector" -------------

	if paramValue := r.URL.Query().Get("selector"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "selector"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "selector", r.URL.Query(), &params.Selector)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selector", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObjectSelector(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostObjectSwitchTo operation middleware
func (siw *ServerInterfaceWrapper) PostObjectSwitchTo(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectSwitchTo(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPools operation middleware
func (siw *ServerInterfaceWrapper) GetPools(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPoolsParams

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPools(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSwagger operation middleware
func (siw *ServerInterfaceWrapper) GetSwagger(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSwagger(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRelayMessage operation middleware
func (siw *ServerInterfaceWrapper) GetRelayMessage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRelayMessageParams

	// ------------- Optional query parameter "nodename" -------------

	err = runtime.BindQueryParameter("form", true, false, "nodename", r.URL.Query(), &params.Nodename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nodename", Err: err})
		return
	}

	// ------------- Optional query parameter "cluster_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "cluster_id", r.URL.Query(), &params.ClusterId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster_id", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRelayMessage(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostRelayMessage operation middleware
func (siw *ServerInterfaceWrapper) PostRelayMessage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostRelayMessage(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshallingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshallingParamError) Error() string {
	return fmt.Sprintf("Error unmarshalling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshallingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token", wrapper.PostAuthToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/dns/dump", wrapper.GetDaemonDNSDump)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/events", wrapper.GetDaemonEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/join", wrapper.PostDaemonJoin)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/leave", wrapper.PostDaemonLeave)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/logs/control", wrapper.PostDaemonLogsControl)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/running", wrapper.GetDaemonRunning)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/status", wrapper.GetDaemonStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/stop", wrapper.PostDaemonStop)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/sub/action", wrapper.PostDaemonSubAction)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/instance/status", wrapper.PostInstanceStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/networks", wrapper.GetNetworks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/node/clear", wrapper.PostNodeClear)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/node/drbd/allocation", wrapper.GetNodeDRBDAllocation)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/node/drbd/config", wrapper.GetNodeDRBDConfig)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/node/drbd/config", wrapper.PostNodeDRBDConfig)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/node/monitor", wrapper.PostNodeMonitor)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/nodes/info", wrapper.GetNodesInfo)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/abort", wrapper.PostObjectAbort)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/clear", wrapper.PostObjectClear)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/object/config", wrapper.GetObjectConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/object/file", wrapper.GetObjectFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/monitor", wrapper.PostObjectMonitor)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/progress", wrapper.PostObjectProgress)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/object/selector", wrapper.GetObjectSelector)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/switchTo", wrapper.PostObjectSwitchTo)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pools", wrapper.GetPools)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/public/openapi", wrapper.GetSwagger)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/relay/message", wrapper.GetRelayMessage)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/relay/message", wrapper.PostRelayMessage)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"97lFJ4YAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
