// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /auth/token)
	PostAuthToken(w http.ResponseWriter, r *http.Request, params PostAuthTokenParams)

	// (GET /daemon/dns/dump)
	GetDaemonDNSDump(w http.ResponseWriter, r *http.Request)

	// (GET /daemon/events)
	GetDaemonEvents(w http.ResponseWriter, r *http.Request, params GetDaemonEventsParams)

	// (POST /daemon/join)
	PostDaemonJoin(w http.ResponseWriter, r *http.Request, params PostDaemonJoinParams)

	// (POST /daemon/leave)
	PostDaemonLeave(w http.ResponseWriter, r *http.Request, params PostDaemonLeaveParams)

	// (POST /daemon/logs/control)
	PostDaemonLogsControl(w http.ResponseWriter, r *http.Request)

	// (GET /daemon/running)
	GetDaemonRunning(w http.ResponseWriter, r *http.Request)

	// (GET /daemon/status)
	GetDaemonStatus(w http.ResponseWriter, r *http.Request, params GetDaemonStatusParams)

	// (POST /daemon/stop)
	PostDaemonStop(w http.ResponseWriter, r *http.Request)

	// (POST /daemon/sub/action)
	PostDaemonSubAction(w http.ResponseWriter, r *http.Request)

	// (POST /instance/status)
	PostInstanceStatus(w http.ResponseWriter, r *http.Request)

	// (POST /node/clear)
	PostNodeClear(w http.ResponseWriter, r *http.Request)

	// (GET /node/drbd/allocation)
	GetNodeDrbdAllocation(w http.ResponseWriter, r *http.Request)

	// (GET /node/file)
	GetNodeFile(w http.ResponseWriter, r *http.Request, params GetNodeFileParams)

	// (POST /node/file)
	PostNodeFile(w http.ResponseWriter, r *http.Request, params PostNodeFileParams)

	// (POST /node/monitor)
	PostNodeMonitor(w http.ResponseWriter, r *http.Request)

	// (GET /nodes/info)
	GetNodesInfo(w http.ResponseWriter, r *http.Request)

	// (POST /object/abort)
	PostObjectAbort(w http.ResponseWriter, r *http.Request)

	// (POST /object/clear)
	PostObjectClear(w http.ResponseWriter, r *http.Request)

	// (GET /object/config)
	GetObjectConfig(w http.ResponseWriter, r *http.Request, params GetObjectConfigParams)

	// (GET /object/file)
	GetObjectFile(w http.ResponseWriter, r *http.Request, params GetObjectFileParams)

	// (POST /object/monitor)
	PostObjectMonitor(w http.ResponseWriter, r *http.Request)

	// (POST /object/progress)
	PostObjectProgress(w http.ResponseWriter, r *http.Request)

	// (GET /object/selector)
	GetObjectSelector(w http.ResponseWriter, r *http.Request, params GetObjectSelectorParams)

	// (POST /object/switchTo)
	PostObjectSwitchTo(w http.ResponseWriter, r *http.Request)

	// (GET /public/openapi)
	GetSwagger(w http.ResponseWriter, r *http.Request)

	// (GET /relay/message)
	GetRelayMessage(w http.ResponseWriter, r *http.Request, params GetRelayMessageParams)

	// (POST /relay/message)
	PostRelayMessage(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// PostAuthToken operation middleware
func (siw *ServerInterfaceWrapper) PostAuthToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthTokenParams

	// ------------- Optional query parameter "role" -------------
	if paramValue := r.URL.Query().Get("role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "role", r.URL.Query(), &params.Role)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "role", Err: err})
		return
	}

	// ------------- Optional query parameter "duration" -------------
	if paramValue := r.URL.Query().Get("duration"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "duration", r.URL.Query(), &params.Duration)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "duration", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthToken(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetDaemonDNSDump operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonDNSDump(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonDNSDump(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetDaemonEvents operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDaemonEventsParams

	// ------------- Optional query parameter "duration" -------------
	if paramValue := r.URL.Query().Get("duration"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "duration", r.URL.Query(), &params.Duration)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "duration", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "filter" -------------
	if paramValue := r.URL.Query().Get("filter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "filter", r.URL.Query(), &params.Filter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonEvents(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostDaemonJoin operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonJoin(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDaemonJoinParams

	// ------------- Required query parameter "node" -------------
	if paramValue := r.URL.Query().Get("node"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "node"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "node", r.URL.Query(), &params.Node)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonJoin(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostDaemonLeave operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonLeave(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDaemonLeaveParams

	// ------------- Required query parameter "node" -------------
	if paramValue := r.URL.Query().Get("node"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "node"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "node", r.URL.Query(), &params.Node)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonLeave(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostDaemonLogsControl operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonLogsControl(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonLogsControl(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetDaemonRunning operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonRunning(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonRunning(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetDaemonStatus operation middleware
func (siw *ServerInterfaceWrapper) GetDaemonStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDaemonStatusParams

	// ------------- Optional query parameter "namespace" -------------
	if paramValue := r.URL.Query().Get("namespace"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "namespace", r.URL.Query(), &params.Namespace)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace", Err: err})
		return
	}

	// ------------- Optional query parameter "relatives" -------------
	if paramValue := r.URL.Query().Get("relatives"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "relatives", r.URL.Query(), &params.Relatives)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relatives", Err: err})
		return
	}

	// ------------- Optional query parameter "selector" -------------
	if paramValue := r.URL.Query().Get("selector"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "selector", r.URL.Query(), &params.Selector)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selector", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDaemonStatus(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostDaemonStop operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonStop(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonStop(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostDaemonSubAction operation middleware
func (siw *ServerInterfaceWrapper) PostDaemonSubAction(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDaemonSubAction(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostInstanceStatus operation middleware
func (siw *ServerInterfaceWrapper) PostInstanceStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostInstanceStatus(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostNodeClear operation middleware
func (siw *ServerInterfaceWrapper) PostNodeClear(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostNodeClear(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetNodeDrbdAllocation operation middleware
func (siw *ServerInterfaceWrapper) GetNodeDrbdAllocation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodeDrbdAllocation(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetNodeFile operation middleware
func (siw *ServerInterfaceWrapper) GetNodeFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNodeFileParams

	// ------------- Required query parameter "kind" -------------
	if paramValue := r.URL.Query().Get("kind"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "kind"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "kind", r.URL.Query(), &params.Kind)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	// ------------- Required query parameter "name" -------------
	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodeFile(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostNodeFile operation middleware
func (siw *ServerInterfaceWrapper) PostNodeFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostNodeFileParams

	// ------------- Required query parameter "kind" -------------
	if paramValue := r.URL.Query().Get("kind"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "kind"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "kind", r.URL.Query(), &params.Kind)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	// ------------- Required query parameter "name" -------------
	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostNodeFile(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostNodeMonitor operation middleware
func (siw *ServerInterfaceWrapper) PostNodeMonitor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostNodeMonitor(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetNodesInfo operation middleware
func (siw *ServerInterfaceWrapper) GetNodesInfo(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodesInfo(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostObjectAbort operation middleware
func (siw *ServerInterfaceWrapper) PostObjectAbort(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectAbort(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostObjectClear operation middleware
func (siw *ServerInterfaceWrapper) PostObjectClear(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectClear(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetObjectConfig operation middleware
func (siw *ServerInterfaceWrapper) GetObjectConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectConfigParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	// ------------- Optional query parameter "evaluate" -------------
	if paramValue := r.URL.Query().Get("evaluate"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "evaluate", r.URL.Query(), &params.Evaluate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "evaluate", Err: err})
		return
	}

	// ------------- Optional query parameter "impersonate" -------------
	if paramValue := r.URL.Query().Get("impersonate"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "impersonate", r.URL.Query(), &params.Impersonate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "impersonate", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObjectConfig(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetObjectFile operation middleware
func (siw *ServerInterfaceWrapper) GetObjectFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectFileParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObjectFile(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostObjectMonitor operation middleware
func (siw *ServerInterfaceWrapper) PostObjectMonitor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectMonitor(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostObjectProgress operation middleware
func (siw *ServerInterfaceWrapper) PostObjectProgress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectProgress(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetObjectSelector operation middleware
func (siw *ServerInterfaceWrapper) GetObjectSelector(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectSelectorParams

	// ------------- Required query parameter "selector" -------------
	if paramValue := r.URL.Query().Get("selector"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "selector"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "selector", r.URL.Query(), &params.Selector)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "selector", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObjectSelector(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostObjectSwitchTo operation middleware
func (siw *ServerInterfaceWrapper) PostObjectSwitchTo(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostObjectSwitchTo(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetSwagger operation middleware
func (siw *ServerInterfaceWrapper) GetSwagger(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSwagger(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRelayMessage operation middleware
func (siw *ServerInterfaceWrapper) GetRelayMessage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRelayMessageParams

	// ------------- Optional query parameter "nodename" -------------
	if paramValue := r.URL.Query().Get("nodename"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nodename", r.URL.Query(), &params.Nodename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nodename", Err: err})
		return
	}

	// ------------- Optional query parameter "cluster_id" -------------
	if paramValue := r.URL.Query().Get("cluster_id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "cluster_id", r.URL.Query(), &params.ClusterId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster_id", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRelayMessage(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostRelayMessage operation middleware
func (siw *ServerInterfaceWrapper) PostRelayMessage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostRelayMessage(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/token", wrapper.PostAuthToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/dns/dump", wrapper.GetDaemonDNSDump)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/events", wrapper.GetDaemonEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/join", wrapper.PostDaemonJoin)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/leave", wrapper.PostDaemonLeave)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/logs/control", wrapper.PostDaemonLogsControl)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/running", wrapper.GetDaemonRunning)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/daemon/status", wrapper.GetDaemonStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/stop", wrapper.PostDaemonStop)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/daemon/sub/action", wrapper.PostDaemonSubAction)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/instance/status", wrapper.PostInstanceStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/node/clear", wrapper.PostNodeClear)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/node/drbd/allocation", wrapper.GetNodeDrbdAllocation)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/node/file", wrapper.GetNodeFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/node/file", wrapper.PostNodeFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/node/monitor", wrapper.PostNodeMonitor)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/nodes/info", wrapper.GetNodesInfo)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/abort", wrapper.PostObjectAbort)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/clear", wrapper.PostObjectClear)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/object/config", wrapper.GetObjectConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/object/file", wrapper.GetObjectFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/monitor", wrapper.PostObjectMonitor)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/progress", wrapper.PostObjectProgress)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/object/selector", wrapper.GetObjectSelector)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/object/switchTo", wrapper.PostObjectSwitchTo)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/public/openapi", wrapper.GetSwagger)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/relay/message", wrapper.GetRelayMessage)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/relay/message", wrapper.PostRelayMessage)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
