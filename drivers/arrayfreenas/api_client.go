// Package arrayfreenas provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package arrayfreenas

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

type respError map[string][]parmError

type parmError struct {
	Message *string `json:"message,omitempty"`
	Errno   *int    `json:"errno,omitempty"`
}

func (t parmError) String() string {
	s := ""
	if t.Errno != nil {
		s += fmt.Sprintf("errno %d: ", *t.Errno)
	}
	if t.Message != nil {
		s += fmt.Sprintf("%s", *t.Message)
	}
	return s
}

func (t respError) String() string {
	s := ""
	for p, perrs := range t {
		s += fmt.Sprintf("param %s:\n", p)
		for _, perr := range perrs {
			s += fmt.Sprintf(" %s\n", perr)
		}
	}
	return strings.TrimSuffix(s, "\n")
}

func (t respError) Error() error {
	s := fmt.Sprint(t)
	if s == "" {
		return nil
	}
	return fmt.Errorf("%s", s)
}

func parseRespError(b []byte) error {
	var e respError
	if err := json.Unmarshal(b, &e); err == nil {
		return e.Error() // maybe nil
	}
	return nil
}

// CompositeValue defines model for CompositeValue.
type CompositeValue struct {
	Rawvalue string  `json:"rawvalue"`
	Source   *string `json:"source,omitempty"`
	Value    *string `json:"value,omitempty"`
}

// CreateCronjobParams defines model for CreateCronjobParams.
type CreateCronjobParams struct {
	Command     string           `json:"command"`
	Description *string          `json:"description,omitempty"`
	Enabled     *bool            `json:"enabled,omitempty"`
	Schedule    *CronJobSchedule `json:"schedule,omitempty"`
	Stderr      *bool            `json:"stderr,omitempty"`
	Stdout      *bool            `json:"stdout,omitempty"`
	User        string           `json:"user"`
}

// CreateGroupParams defines model for CreateGroupParams.
type CreateGroupParams struct {
	AllowDuplicateGid *bool     `json:"allow_duplicate_gid,omitempty"`
	Gid               *int      `json:"gid,omitempty"`
	Name              string    `json:"name"`
	Smb               *bool     `json:"smb,omitempty"`
	Sudo              *bool     `json:"sudo,omitempty"`
	SudoCommands      *[]string `json:"sudo_commands,omitempty"`
	SudoNopasswd      *bool     `json:"sudo_nopasswd,omitempty"`
	Users             *[]int    `json:"users,omitempty"`
}

// CreateShareNFSParams defines model for CreateShareNFSParams.
type CreateShareNFSParams struct {
	Alldirs      *bool     `json:"alldirs,omitempty"`
	Comment      *string   `json:"comment,omitempty"`
	Enabled      *bool     `json:"enabled,omitempty"`
	Hosts        *[]string `json:"hosts,omitempty"`
	MapallGroup  *string   `json:"mapall_group,omitempty"`
	MapallUser   *string   `json:"mapall_user,omitempty"`
	MaprootGroup *string   `json:"maproot_group,omitempty"`
	MaprootUser  *string   `json:"maproot_user,omitempty"`
	Networks     *[]string `json:"networks,omitempty"`
	Paths        []string  `json:"paths"`
	Quiet        *bool     `json:"quiet,omitempty"`
	Ro           *bool     `json:"ro,omitempty"`
	Security     *[]string `json:"security,omitempty"`
}

// CreateShareSMBParams defines model for CreateShareSMBParams.
type CreateShareSMBParams struct {
	AaplNameMangling *bool     `json:"aapl_name_mangling,omitempty"`
	Abe              *bool     `json:"abe,omitempty"`
	Acl              *bool     `json:"acl,omitempty"`
	Auxsmbconf       *string   `json:"auxsmbconf,omitempty"`
	Browsable        *bool     `json:"browsable,omitempty"`
	Comment          *string   `json:"comment,omitempty"`
	Durablehandle    *bool     `json:"durablehandle,omitempty"`
	Enabled          *bool     `json:"enabled,omitempty"`
	Fsrvp            *bool     `json:"fsrvp,omitempty"`
	Guestok          *bool     `json:"guestok,omitempty"`
	Home             *bool     `json:"home,omitempty"`
	Hostsallow       *[]string `json:"hostsallow,omitempty"`
	Hostsdeny        *[]string `json:"hostsdeny,omitempty"`
	Name             *string   `json:"name,omitempty"`
	Path             string    `json:"path"`
	PathSuffix       *string   `json:"path_suffix,omitempty"`
	Purpose          *string   `json:"purpose,omitempty"`
	Recyclebin       *bool     `json:"recyclebin,omitempty"`
	Ro               *bool     `json:"ro,omitempty"`
	Shadowcopy       *bool     `json:"shadowcopy,omitempty"`
	Streams          *bool     `json:"streams,omitempty"`
	Timemachine      *bool     `json:"timemachine,omitempty"`
}

// CreateUserParams defines model for CreateUserParams.
type CreateUserParams struct {
	Attributes       *CreateUserParams_Attributes `json:"attributes,omitempty"`
	Email            *string                      `json:"email"`
	FullName         string                       `json:"full_name"`
	Group            *int                         `json:"group,omitempty"`
	GroupCreate      *bool                        `json:"group_create,omitempty"`
	Groups           *[]int                       `json:"groups,omitempty"`
	Home             *string                      `json:"home,omitempty"`
	HomeMode         *string                      `json:"home_mode,omitempty"`
	Locked           *bool                        `json:"locked,omitempty"`
	MicrosoftAccount *bool                        `json:"microsoft_account,omitempty"`
	Password         *string                      `json:"password,omitempty"`
	PasswordDisabled *bool                        `json:"password_disabled,omitempty"`
	Shell            *string                      `json:"shell,omitempty"`
	Smb              *bool                        `json:"smb,omitempty"`
	Sshpubkey        *string                      `json:"sshpubkey"`
	Sudo             *bool                        `json:"sudo,omitempty"`
	SudoCommands     *[]string                    `json:"sudo_commands,omitempty"`
	SudoNopasswd     *bool                        `json:"sudo_nopasswd,omitempty"`
	Uid              *int                         `json:"uid,omitempty"`
	Username         string                       `json:"username"`
}

// CreateUserParams_Attributes defines model for CreateUserParams.Attributes.
type CreateUserParams_Attributes struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CronJob defines model for CronJob.
type CronJob struct {
	Command     *string          `json:"command,omitempty"`
	Description *string          `json:"description,omitempty"`
	Enabled     *bool            `json:"enabled,omitempty"`
	Id          *int             `json:"id,omitempty"`
	Schedule    *CronJobSchedule `json:"schedule,omitempty"`
	Stderr      *bool            `json:"stderr,omitempty"`
	Stdout      *bool            `json:"stdout,omitempty"`
	User        *string          `json:"user,omitempty"`
}

// CronJobSchedule defines model for CronJobSchedule.
type CronJobSchedule struct {
	Dom    *string `json:"dom,omitempty"`
	Dow    *string `json:"dow,omitempty"`
	Hour   *string `json:"hour,omitempty"`
	Minute *string `json:"minute,omitempty"`
	Month  *string `json:"month,omitempty"`
}

// Dataset defines model for Dataset.
type Dataset struct {
	Aclmode             *CompositeValue `json:"aclmode,omitempty"`
	Acltype             *CompositeValue `json:"acltype,omitempty"`
	Atime               *CompositeValue `json:"atime,omitempty"`
	Available           *CompositeValue `json:"available,omitempty"`
	Casesensitivity     *CompositeValue `json:"casesensitivity,omitempty"`
	Comments            *CompositeValue `json:"comments,omitempty"`
	Compression         *CompositeValue `json:"compression,omitempty"`
	Copies              *CompositeValue `json:"copies,omitempty"`
	Deduplication       *CompositeValue `json:"deduplication,omitempty"`
	Encrypted           *bool           `json:"encrypted,omitempty"`
	EncryptionAlgorithm *CompositeValue `json:"encryption_algorithm,omitempty"`
	EncryptionRoot      *string         `json:"encryption_root,omitempty"`
	Exec                *CompositeValue `json:"exec,omitempty"`
	Id                  string          `json:"id"`
	KeyFormat           *CompositeValue `json:"key_format,omitempty"`
	KeyLoaded           *bool           `json:"key_loaded,omitempty"`
	Locked              *bool           `json:"locked,omitempty"`
	Managedby           *CompositeValue `json:"managedby,omitempty"`
	Mountpoint          *string         `json:"mountpoint,omitempty"`
	Name                string          `json:"name"`
	Origin              *CompositeValue `json:"origin,omitempty"`
	Pbkdf2iters         *CompositeValue `json:"pbkdf2iters,omitempty"`
	Pool                string          `json:"pool"`
	Quota               *CompositeValue `json:"quota,omitempty"`
	QuotaCritical       *CompositeValue `json:"quota_critical,omitempty"`
	QuotaWarning        *CompositeValue `json:"quota_warning,omitempty"`
	Readonly            *CompositeValue `json:"readonly,omitempty"`
	Recordsize          *CompositeValue `json:"recordsize,omitempty"`
	Refquota            *CompositeValue `json:"refquota,omitempty"`
	RefquotaCritical    *CompositeValue `json:"refquota_critical,omitempty"`
	RefquotaWarning     *CompositeValue `json:"refquota_warning,omitempty"`
	Refreservation      *CompositeValue `json:"refreservation,omitempty"`
	Reservation         *CompositeValue `json:"reservation,omitempty"`
	Snapdir             *CompositeValue `json:"snapdir,omitempty"`
	Sync                *CompositeValue `json:"sync,omitempty"`
	Type                string          `json:"type"`
	Used                *CompositeValue `json:"used,omitempty"`
	Volblocksize        *CompositeValue `json:"volblocksize,omitempty"`
	Volsize             *CompositeValue `json:"volsize,omitempty"`
	Xattr               *CompositeValue `json:"xattr,omitempty"`
}

type Datasets []Dataset

// DeleteGroupParams defines model for DeleteGroupParams.
type DeleteGroupParams struct {
	DeleteUsers *bool `json:"delete_users,omitempty"`
}

// DeleteUserParams defines model for DeleteUserParams.
type DeleteUserParams struct {
	DeleteGroup *bool `json:"delete_group,omitempty"`
}

// Group defines model for Group.
type Group struct {
	Builtin      *bool     `json:"builtin,omitempty"`
	Gid          *int      `json:"gid,omitempty"`
	Group        string    `json:"group"`
	Id           int       `json:"id"`
	IdTypeBoth   *bool     `json:"id_type_both,omitempty"`
	Local        *bool     `json:"local,omitempty"`
	Smb          *bool     `json:"smb,omitempty"`
	Sudo         *bool     `json:"sudo,omitempty"`
	SudoCommands *[]string `json:"sudo_commands,omitempty"`
	SudoNopasswd *bool     `json:"sudo_nopasswd,omitempty"`
	Users        *[]int    `json:"users,omitempty"`
}

// GroupResponse defines model for GroupResponse.
type GroupResponse = int

// ListDatasetResponse defines model for ListDatasetResponse.
type ListDatasetResponse = []Dataset

// NetworkConfig defines model for NetworkConfig.
type NetworkConfig struct {
	Domain              *string                           `json:"domain,omitempty"`
	Domains             *[]string                         `json:"domains,omitempty"`
	Hostname            *string                           `json:"hostname,omitempty"`
	HostnameLocal       *string                           `json:"hostname_local,omitempty"`
	Hosts               *string                           `json:"hosts,omitempty"`
	Httpproxy           *string                           `json:"httpproxy,omitempty"`
	Id                  *int                              `json:"id,omitempty"`
	Ipv4gateway         *string                           `json:"ipv4gateway,omitempty"`
	Ipv6gateway         *string                           `json:"ipv6gateway,omitempty"`
	Nameserver1         *string                           `json:"nameserver1,omitempty"`
	Nameserver2         *string                           `json:"nameserver2,omitempty"`
	Nameserver3         *string                           `json:"nameserver3,omitempty"`
	NetwaitEnabled      *bool                             `json:"netwait_enabled,omitempty"`
	NetwaitIp           *[]string                         `json:"netwait_ip,omitempty"`
	ServiceAnnouncement *NetworkConfigServiceAnnouncement `json:"service_announcement,omitempty"`
}

// NetworkConfigServiceAnnouncement defines model for NetworkConfig_service_announcement.
type NetworkConfigServiceAnnouncement struct {
	Mdns    *bool `json:"mdns,omitempty"`
	Netbios *bool `json:"netbios,omitempty"`
	Wsd     *bool `json:"wsd,omitempty"`
}

// NetworkSummary defines model for NetworkSummary.
type NetworkSummary struct {
	DefaultRoutes *[]string           `json:"default_routes,omitempty"`
	Ips           *NetworkSummary_Ips `json:"ips,omitempty"`
	Nameservers   *[]string           `json:"nameservers,omitempty"`
}

// NetworkSummary_Ips defines model for NetworkSummary.Ips.
type NetworkSummary_Ips struct {
	AdditionalProperties map[string]NetworkSummaryIpsValue `json:"-"`
}

// NetworkSummaryIpsValue defines model for NetworkSummary_ips_value.
type NetworkSummaryIpsValue struct {
	IPV4 *[]string `json:"IPV4,omitempty"`
	IPV6 *[]string `json:"IPV6,omitempty"`
}

// Service defines model for Service.
type Service struct {
	Enable  *bool   `json:"enable,omitempty"`
	Id      int     `json:"id"`
	Pids    *[]int  `json:"pids,omitempty"`
	Service string  `json:"service"`
	State   *string `json:"state,omitempty"`
}

// ShareNFS defines model for ShareNFS.
type ShareNFS struct {
	Alldirs      *bool     `json:"alldirs,omitempty"`
	Comment      *string   `json:"comment,omitempty"`
	Enabled      *bool     `json:"enabled,omitempty"`
	Hosts        *[]string `json:"hosts,omitempty"`
	Id           int       `json:"id"`
	Locked       *bool     `json:"locked,omitempty"`
	MapallGroup  *string   `json:"mapall_group,omitempty"`
	MapallUser   *string   `json:"mapall_user,omitempty"`
	MaprootGroup *string   `json:"maproot_group,omitempty"`
	MaprootUser  *string   `json:"maproot_user,omitempty"`
	Networks     *[]string `json:"networks,omitempty"`
	Paths        []string  `json:"paths"`
	Quiet        *bool     `json:"quiet,omitempty"`
	Ro           *bool     `json:"ro,omitempty"`
	Security     *[]string `json:"security,omitempty"`
}

// ShareSMB defines model for ShareSMB.
type ShareSMB struct {
	AaplNameMangling *bool     `json:"aapl_name_mangling,omitempty"`
	Abe              *bool     `json:"abe,omitempty"`
	Acl              *bool     `json:"acl,omitempty"`
	Auxsmbconf       *string   `json:"auxsmbconf,omitempty"`
	Browsable        *bool     `json:"browsable,omitempty"`
	Comment          *string   `json:"comment,omitempty"`
	Durablehandle    *bool     `json:"durablehandle,omitempty"`
	Enabled          *bool     `json:"enabled,omitempty"`
	Fsrvp            *bool     `json:"fsrvp,omitempty"`
	Guestok          *bool     `json:"guestok,omitempty"`
	Home             *bool     `json:"home,omitempty"`
	Hostsallow       *[]string `json:"hostsallow,omitempty"`
	Hostsdeny        *[]string `json:"hostsdeny,omitempty"`
	Id               int       `json:"id"`
	Locked           *bool     `json:"locked,omitempty"`
	Name             *string   `json:"name,omitempty"`
	Path             string    `json:"path"`
	PathSuffix       *string   `json:"path_suffix,omitempty"`
	Purpose          *string   `json:"purpose,omitempty"`
	Recyclebin       *bool     `json:"recyclebin,omitempty"`
	Ro               *bool     `json:"ro,omitempty"`
	Shadowcopy       *bool     `json:"shadowcopy,omitempty"`
	Streams          *bool     `json:"streams,omitempty"`
	Timemachine      *bool     `json:"timemachine,omitempty"`
	Vuid             *string   `json:"vuid,omitempty"`
}

// SharesNFSResponse defines model for SharesNFSResponse.
type SharesNFSResponse = []ShareNFS

// SharesSMBResponse defines model for SharesSMBResponse.
type SharesSMBResponse = []ShareSMB

// UpdateUserParams defines model for UpdateUserParams.
type UpdateUserParams struct {
	Attributes       *UpdateUserParams_Attributes `json:"attributes,omitempty"`
	Email            *string                      `json:"email"`
	FullName         *string                      `json:"full_name,omitempty"`
	Group            *int                         `json:"group,omitempty"`
	Groups           *[]int                       `json:"groups,omitempty"`
	Home             *string                      `json:"home,omitempty"`
	HomeMode         *string                      `json:"home_mode,omitempty"`
	Locked           *bool                        `json:"locked,omitempty"`
	MicrosoftAccount *bool                        `json:"microsoft_account,omitempty"`
	Password         *string                      `json:"password,omitempty"`
	PasswordDisabled *bool                        `json:"password_disabled,omitempty"`
	Shell            *string                      `json:"shell,omitempty"`
	Smb              *bool                        `json:"smb,omitempty"`
	Sshpubkey        *string                      `json:"sshpubkey"`
	Sudo             *bool                        `json:"sudo,omitempty"`
	SudoCommands     *[]string                    `json:"sudo_commands,omitempty"`
	SudoNopasswd     *bool                        `json:"sudo_nopasswd,omitempty"`
	Uid              *int                         `json:"uid,omitempty"`
	Username         *string                      `json:"username,omitempty"`
}

// UpdateUserParams_Attributes defines model for UpdateUserParams.Attributes.
type UpdateUserParams_Attributes struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// User defines model for User.
type User struct {
	Attributes       *User_Attributes `json:"attributes,omitempty"`
	Builtin          *bool            `json:"builtin,omitempty"`
	Email            *string          `json:"email"`
	FullName         string           `json:"full_name"`
	Group            *UserGroup       `json:"group,omitempty"`
	Groups           *[]int           `json:"groups,omitempty"`
	Home             *string          `json:"home,omitempty"`
	Id               int              `json:"id"`
	IdTypeBoth       *bool            `json:"id_type_both,omitempty"`
	Local            *bool            `json:"local,omitempty"`
	Locked           *bool            `json:"locked,omitempty"`
	MicrosoftAccount *bool            `json:"microsoft_account,omitempty"`
	PasswordDisabled *bool            `json:"password_disabled,omitempty"`
	Shell            *string          `json:"shell,omitempty"`
	Smb              *bool            `json:"smb,omitempty"`
	Smbhash          *string          `json:"smbhash,omitempty"`
	Sshpubkey        *string          `json:"sshpubkey"`
	Sudo             *bool            `json:"sudo,omitempty"`
	SudoCommands     *[]string        `json:"sudo_commands,omitempty"`
	SudoNopasswd     *bool            `json:"sudo_nopasswd,omitempty"`
	Uid              *int             `json:"uid,omitempty"`
	Unixhash         *string          `json:"unixhash,omitempty"`
	Username         string           `json:"username"`
}

// User_Attributes defines model for User.Attributes.
type User_Attributes struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UserResponse defines model for UserResponse.
type UserResponse = int

// UserShellChoices defines model for UserShellChoices.
type UserShellChoices struct {
	AdditionalProperties map[string]string `json:"-"`
}

// UserShellChoicesParams defines model for UserShellChoicesParams.
type UserShellChoicesParams = int

// UserGroup defines model for User_group.
type UserGroup struct {
	BsdgrpBuiltin      *bool     `json:"bsdgrp_builtin,omitempty"`
	BsdgrpGid          *int      `json:"bsdgrp_gid,omitempty"`
	BsdgrpGroup        *string   `json:"bsdgrp_group,omitempty"`
	BsdgrpSmb          *bool     `json:"bsdgrp_smb,omitempty"`
	BsdgrpSudo         *bool     `json:"bsdgrp_sudo,omitempty"`
	BsdgrpSudoCommands *[]string `json:"bsdgrp_sudo_commands,omitempty"`
	BsdgrpSudoNopasswd *bool     `json:"bsdgrp_sudo_nopasswd,omitempty"`
	Id                 *int      `json:"id,omitempty"`
}

// UsersResponse defines model for UsersResponse.
type UsersResponse = []User

// VM defines model for VM.
type VM struct {
	Autostart       *bool             `json:"autostart,omitempty"`
	Bootloader      *string           `json:"bootloader,omitempty"`
	Cores           *int              `json:"cores,omitempty"`
	Description     *string           `json:"description,omitempty"`
	Devices         *[]VMDevicesInner `json:"devices,omitempty"`
	Id              int               `json:"id"`
	Memory          *int              `json:"memory,omitempty"`
	Name            string            `json:"name"`
	ShutdownTimeout *int              `json:"shutdown_timeout,omitempty"`
	Status          *VMStatus         `json:"status,omitempty"`
	Threads         *int              `json:"threads,omitempty"`
	Time            *string           `json:"time,omitempty"`
	Vcpus           *int              `json:"vcpus,omitempty"`
}

// VMSResponse defines model for VMSResponse.
type VMSResponse = []VM

// VMDevicesInner defines model for VM_devices_inner.
type VMDevicesInner struct {
	Attributes *map[string]interface{} `json:"attributes,omitempty"`
	Dtype      string                  `json:"dtype"`
	Id         int                     `json:"id"`
	Order      *int                    `json:"order,omitempty"`
	Vm         *int                    `json:"vm,omitempty"`
}

// VMStatus defines model for VM_status.
type VMStatus struct {
	DomainState *string `json:"domain_state,omitempty"`
	Pid         *int    `json:"pid,omitempty"`
	State       *string `json:"state,omitempty"`
}

// CreateCronJobJSONBody defines parameters for CreateCronJob.
type CreateCronJobJSONBody = CreateCronjobParams

// GetCronJobParams defines parameters for GetCronJob.
type GetCronJobParams struct {
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Sort   *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// UpdateCronJobJSONBody defines parameters for UpdateCronJob.
type UpdateCronJobJSONBody = CreateCronjobParams

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Sort   *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody = CreateGroupParams

// DeleteGroupJSONBody defines parameters for DeleteGroup.
type DeleteGroupJSONBody = DeleteGroupParams

// GetGroupParams defines parameters for GetGroup.
type GetGroupParams struct {
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Sort   *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// UpdateGroupJSONBody defines parameters for UpdateGroup.
type UpdateGroupJSONBody = CreateGroupParams

// GetServiceParams defines parameters for GetService.
type GetServiceParams struct {
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Sort   *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListSharesNFSParams defines parameters for ListSharesNFS.
type ListSharesNFSParams struct {
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Sort   *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// CreateShareNFSJSONBody defines parameters for CreateShareNFS.
type CreateShareNFSJSONBody = CreateShareNFSParams

// GetShareNFSParams defines parameters for GetShareNFS.
type GetShareNFSParams struct {
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Sort   *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// UpdateShareNFSJSONBody defines parameters for UpdateShareNFS.
type UpdateShareNFSJSONBody = CreateShareNFSParams

// ListSharesSMBParams defines parameters for ListSharesSMB.
type ListSharesSMBParams struct {
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Sort   *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// CreateShareSMBJSONBody defines parameters for CreateShareSMB.
type CreateShareSMBJSONBody = CreateShareSMBParams

// GetShareSMBParams defines parameters for GetShareSMB.
type GetShareSMBParams struct {
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Sort   *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// UpdateShareSMBJSONBody defines parameters for UpdateShareSMB.
type UpdateShareSMBJSONBody = CreateShareSMBParams

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Sort   *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody = CreateUserParams

// DeleteUserJSONBody defines parameters for DeleteUser.
type DeleteUserJSONBody = DeleteUserParams

// GetUserParams defines parameters for GetUser.
type GetUserParams struct {
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Sort   *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody = UpdateUserParams

// GetUserShellChoicesJSONBody defines parameters for GetUserShellChoices.
type GetUserShellChoicesJSONBody = UserShellChoicesParams

// ListVMSParams defines parameters for ListVMS.
type ListVMSParams struct {
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Sort   *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetVMParams defines parameters for GetVM.
type GetVMParams struct {
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Sort   *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// CreateCronJobJSONRequestBody defines body for CreateCronJob for application/json ContentType.
type CreateCronJobJSONRequestBody = CreateCronJobJSONBody

// UpdateCronJobJSONRequestBody defines body for UpdateCronJob for application/json ContentType.
type UpdateCronJobJSONRequestBody = UpdateCronJobJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody = CreateGroupJSONBody

// DeleteGroupJSONRequestBody defines body for DeleteGroup for application/json ContentType.
type DeleteGroupJSONRequestBody = DeleteGroupJSONBody

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody = UpdateGroupJSONBody

// CreateShareNFSJSONRequestBody defines body for CreateShareNFS for application/json ContentType.
type CreateShareNFSJSONRequestBody = CreateShareNFSJSONBody

// UpdateShareNFSJSONRequestBody defines body for UpdateShareNFS for application/json ContentType.
type UpdateShareNFSJSONRequestBody = UpdateShareNFSJSONBody

// CreateShareSMBJSONRequestBody defines body for CreateShareSMB for application/json ContentType.
type CreateShareSMBJSONRequestBody = CreateShareSMBJSONBody

// UpdateShareSMBJSONRequestBody defines body for UpdateShareSMB for application/json ContentType.
type UpdateShareSMBJSONRequestBody = UpdateShareSMBJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = CreateUserJSONBody

// DeleteUserJSONRequestBody defines body for DeleteUser for application/json ContentType.
type DeleteUserJSONRequestBody = DeleteUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UpdateUserJSONBody

// GetUserShellChoicesJSONRequestBody defines body for GetUserShellChoices for application/json ContentType.
type GetUserShellChoicesJSONRequestBody = GetUserShellChoicesJSONBody

// Getter for additional properties for CreateUserParams_Attributes. Returns the specified
// element and whether it was found
func (a CreateUserParams_Attributes) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateUserParams_Attributes
func (a *CreateUserParams_Attributes) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateUserParams_Attributes to handle AdditionalProperties
func (a *CreateUserParams_Attributes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateUserParams_Attributes to handle AdditionalProperties
func (a CreateUserParams_Attributes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NetworkSummary_Ips. Returns the specified
// element and whether it was found
func (a NetworkSummary_Ips) Get(fieldName string) (value NetworkSummaryIpsValue, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NetworkSummary_Ips
func (a *NetworkSummary_Ips) Set(fieldName string, value NetworkSummaryIpsValue) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]NetworkSummaryIpsValue)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NetworkSummary_Ips to handle AdditionalProperties
func (a *NetworkSummary_Ips) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]NetworkSummaryIpsValue)
		for fieldName, fieldBuf := range object {
			var fieldVal NetworkSummaryIpsValue
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NetworkSummary_Ips to handle AdditionalProperties
func (a NetworkSummary_Ips) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateUserParams_Attributes. Returns the specified
// element and whether it was found
func (a UpdateUserParams_Attributes) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateUserParams_Attributes
func (a *UpdateUserParams_Attributes) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateUserParams_Attributes to handle AdditionalProperties
func (a *UpdateUserParams_Attributes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateUserParams_Attributes to handle AdditionalProperties
func (a UpdateUserParams_Attributes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for User_Attributes. Returns the specified
// element and whether it was found
func (a User_Attributes) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for User_Attributes
func (a *User_Attributes) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for User_Attributes to handle AdditionalProperties
func (a *User_Attributes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for User_Attributes to handle AdditionalProperties
func (a User_Attributes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UserShellChoices. Returns the specified
// element and whether it was found
func (a UserShellChoices) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UserShellChoices
func (a *UserShellChoices) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UserShellChoices to handle AdditionalProperties
func (a *UserShellChoices) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UserShellChoices to handle AdditionalProperties
func (a UserShellChoices) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateCronJob request with any body
	CreateCronJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCronJob(ctx context.Context, body CreateCronJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCronJob request
	DeleteCronJob(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCronJob request
	GetCronJob(ctx context.Context, id int, params *GetCronJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCronJob request with any body
	UpdateCronJobWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCronJob(ctx context.Context, id int, body UpdateCronJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroups request
	ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroup request with any body
	CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request with any body
	DeleteGroupWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteGroup(ctx context.Context, id int, body DeleteGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, id int, params *GetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroup request with any body
	UpdateGroupWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroup(ctx context.Context, id int, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkConfiguration request
	GetNetworkConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkSummary request
	GetNetworkSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemInfo request
	GetSystemInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetISCSITargets request
	GetISCSITargets(ctx context.Context, params *GetISCSITargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetISCSIExtents request
	GetISCSIExtents(ctx context.Context, params *GetISCSIExtentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetISCSITargetExtents request
	GetISCSITargetExtents(ctx context.Context, params *GetISCSITargetExtentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetISCSIInitiators request
	GetISCSIInitiators(ctx context.Context, params *GetISCSIInitiatorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPools request
	GetPools(ctx context.Context, params *GetPoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatasets request
	GetDatasets(ctx context.Context, params *GetDatasetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateISCSIExtent request with any body
	CreateISCSIExtentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateISCSIExtent(ctx context.Context, body CreateISCSIExtentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateISCSITargetExtent request with any body
	CreateISCSITargetExtentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateISCSITargetExtent(ctx context.Context, body CreateISCSITargetExtentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDataset request with any body
	CreateDatasetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDataset(ctx context.Context, body CreateDatasetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteISCSIExtent request
	DeleteISCSIExtent(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteISCSITargetExtent request
	DeleteISCSITargetExtent(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDataset request
	DeleteDataset(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataset request
	GetDataset(ctx context.Context, id string, params *GetDatasetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDataset request with any body
	UpdateDatasetWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDataset(ctx context.Context, id string, body UpdateDatasetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetService request
	GetService(ctx context.Context, id int, params *GetServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSharesNFS request
	ListSharesNFS(ctx context.Context, params *ListSharesNFSParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateShareNFS request with any body
	CreateShareNFSWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateShareNFS(ctx context.Context, body CreateShareNFSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveShareNFS request
	RemoveShareNFS(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShareNFS request
	GetShareNFS(ctx context.Context, id int, params *GetShareNFSParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateShareNFS request with any body
	UpdateShareNFSWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateShareNFS(ctx context.Context, id int, body UpdateShareNFSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSharesSMB request
	ListSharesSMB(ctx context.Context, params *ListSharesSMBParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateShareSMB request with any body
	CreateShareSMBWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateShareSMB(ctx context.Context, body CreateShareSMBJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveShareSMB request
	RemoveShareSMB(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShareSMB request
	GetShareSMB(ctx context.Context, id int, params *GetShareSMBParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateShareSMB request with any body
	UpdateShareSMBWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateShareSMB(ctx context.Context, id int, body UpdateShareSMBJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request with any body
	DeleteUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUser(ctx context.Context, id int, body DeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, id int, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUser request with any body
	UpdateUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserShellChoices request with any body
	GetUserShellChoicesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetUserShellChoices(ctx context.Context, body GetUserShellChoicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVMS request
	ListVMS(ctx context.Context, params *ListVMSParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVM request
	GetVM(ctx context.Context, id int, params *GetVMParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateCronJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCronJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCronJob(ctx context.Context, body CreateCronJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCronJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCronJob(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCronJobRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCronJob(ctx context.Context, id int, params *GetCronJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCronJobRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCronJobWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCronJobRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCronJob(ctx context.Context, id int, body UpdateCronJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCronJobRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, id int, body DeleteGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, id int, params *GetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroup(ctx context.Context, id int, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkSummaryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetService(ctx context.Context, id int, params *GetServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSharesNFS(ctx context.Context, params *ListSharesNFSParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSharesNFSRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateShareNFSWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateShareNFSRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateShareNFS(ctx context.Context, body CreateShareNFSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateShareNFSRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveShareNFS(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveShareNFSRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShareNFS(ctx context.Context, id int, params *GetShareNFSParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShareNFSRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShareNFSWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShareNFSRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShareNFS(ctx context.Context, id int, body UpdateShareNFSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShareNFSRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSharesSMB(ctx context.Context, params *ListSharesSMBParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSharesSMBRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateShareSMBWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateShareSMBRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateShareSMB(ctx context.Context, body CreateShareSMBJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateShareSMBRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveShareSMB(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveShareSMBRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShareSMB(ctx context.Context, id int, params *GetShareSMBParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShareSMBRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShareSMBWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShareSMBRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShareSMB(ctx context.Context, id int, body UpdateShareSMBJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShareSMBRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, id int, body DeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, id int, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserShellChoicesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserShellChoicesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserShellChoices(ctx context.Context, body GetUserShellChoicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserShellChoicesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVMS(ctx context.Context, params *ListVMSParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVMSRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVM(ctx context.Context, id int, params *GetVMParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVMRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateCronJobRequest calls the generic CreateCronJob builder with application/json body
func NewCreateCronJobRequest(server string, body CreateCronJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCronJobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCronJobRequestWithBody generates requests for CreateCronJob with any type of body
func NewCreateCronJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cronjob")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCronJobRequest generates requests for DeleteCronJob
func NewDeleteCronJobRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cronjob/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCronJobRequest generates requests for GetCronJob
func NewGetCronJobRequest(server string, id int, params *GetCronJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cronjob/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCronJobRequest calls the generic UpdateCronJob builder with application/json body
func NewUpdateCronJobRequest(server string, id int, body UpdateCronJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCronJobRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateCronJobRequestWithBody generates requests for UpdateCronJob with any type of body
func NewUpdateCronJobRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cronjob/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupsRequest generates requests for ListGroups
func NewListGroupsRequest(server string, params *ListGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest calls the generic DeleteGroup builder with application/json body
func NewDeleteGroupRequest(server string, id int, body DeleteGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteGroupRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteGroupRequestWithBody generates requests for DeleteGroup with any type of body
func NewDeleteGroupRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, id int, params *GetGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGroupRequest calls the generic UpdateGroup builder with application/json body
func NewUpdateGroupRequest(server string, id int, body UpdateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateGroupRequestWithBody generates requests for UpdateGroup with any type of body
func NewUpdateGroupRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNetworkConfigurationRequest generates requests for GetNetworkConfiguration
func NewGetNetworkConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkSummaryRequest generates requests for GetNetworkSummary
func NewGetNetworkSummaryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/general/summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceRequest generates requests for GetService
func NewGetServiceRequest(server string, id int, params *GetServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSharesNFSRequest generates requests for ListSharesNFS
func NewListSharesNFSRequest(server string, params *ListSharesNFSParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sharing/nfs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateShareNFSRequest calls the generic CreateShareNFS builder with application/json body
func NewCreateShareNFSRequest(server string, body CreateShareNFSJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateShareNFSRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateShareNFSRequestWithBody generates requests for CreateShareNFS with any type of body
func NewCreateShareNFSRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sharing/nfs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveShareNFSRequest generates requests for RemoveShareNFS
func NewRemoveShareNFSRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sharing/nfs/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShareNFSRequest generates requests for GetShareNFS
func NewGetShareNFSRequest(server string, id int, params *GetShareNFSParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sharing/nfs/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateShareNFSRequest calls the generic UpdateShareNFS builder with application/json body
func NewUpdateShareNFSRequest(server string, id int, body UpdateShareNFSJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShareNFSRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateShareNFSRequestWithBody generates requests for UpdateShareNFS with any type of body
func NewUpdateShareNFSRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sharing/nfs/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSharesSMBRequest generates requests for ListSharesSMB
func NewListSharesSMBRequest(server string, params *ListSharesSMBParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sharing/smb")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateShareSMBRequest calls the generic CreateShareSMB builder with application/json body
func NewCreateShareSMBRequest(server string, body CreateShareSMBJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateShareSMBRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateShareSMBRequestWithBody generates requests for CreateShareSMB with any type of body
func NewCreateShareSMBRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sharing/smb")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveShareSMBRequest generates requests for RemoveShareSMB
func NewRemoveShareSMBRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sharing/smb/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShareSMBRequest generates requests for GetShareSMB
func NewGetShareSMBRequest(server string, id int, params *GetShareSMBParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sharing/smb/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateShareSMBRequest calls the generic UpdateShareSMB builder with application/json body
func NewUpdateShareSMBRequest(server string, id int, body UpdateShareSMBJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShareSMBRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateShareSMBRequestWithBody generates requests for UpdateShareSMB with any type of body
func NewUpdateShareSMBRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sharing/smb/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest calls the generic DeleteUser builder with application/json body
func NewDeleteUserRequest(server string, id int, body DeleteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUserRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteUserRequestWithBody generates requests for DeleteUser with any type of body
func NewDeleteUserRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, id int, params *GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, id int, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserShellChoicesRequest calls the generic GetUserShellChoices builder with application/json body
func NewGetUserShellChoicesRequest(server string, body GetUserShellChoicesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetUserShellChoicesRequestWithBody(server, "application/json", bodyReader)
}

// NewGetUserShellChoicesRequestWithBody generates requests for GetUserShellChoices with any type of body
func NewGetUserShellChoicesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/shell_choices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVMSRequest generates requests for ListVMS
func NewListVMSRequest(server string, params *ListVMSParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVMRequest generates requests for GetVM
func NewGetVMRequest(server string, id int, params *GetVMParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/id/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateCronJob request with any body
	CreateCronJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCronJobResponse, error)

	CreateCronJobWithResponse(ctx context.Context, body CreateCronJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCronJobResponse, error)

	// DeleteCronJob request
	DeleteCronJobWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteCronJobResponse, error)

	// GetCronJob request
	GetCronJobWithResponse(ctx context.Context, id int, params *GetCronJobParams, reqEditors ...RequestEditorFn) (*GetCronJobResponse, error)

	// UpdateCronJob request with any body
	UpdateCronJobWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCronJobResponse, error)

	UpdateCronJobWithResponse(ctx context.Context, id int, body UpdateCronJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCronJobResponse, error)

	// ListGroups request
	ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error)

	// CreateGroup request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroup request with any body
	DeleteGroupWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	DeleteGroupWithResponse(ctx context.Context, id int, body DeleteGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroup request
	GetGroupWithResponse(ctx context.Context, id int, params *GetGroupParams, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// UpdateGroup request with any body
	UpdateGroupWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	UpdateGroupWithResponse(ctx context.Context, id int, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	// GetNetworkConfiguration request
	GetNetworkConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNetworkConfigurationResponse, error)

	// GetNetworkSummary request
	GetNetworkSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNetworkSummaryResponse, error)

	// GetPools request
	GetPoolsWithResponse(ctx context.Context, params *GetPoolsParams, reqEditors ...RequestEditorFn) (*GetPoolsResponse, error)

	// GetISCSITargets request
	GetISCSITargetsWithResponse(ctx context.Context, params *GetISCSITargetsParams, reqEditors ...RequestEditorFn) (*GetISCSITargetsResponse, error)

	// GetISCSITargetExtents request
	GetISCSITargetExtentsWithResponse(ctx context.Context, params *GetISCSITargetExtentsParams, reqEditors ...RequestEditorFn) (*GetISCSITargetExtentsResponse, error)

	// GetISCSIExtents request
	GetISCSIExtentsWithResponse(ctx context.Context, params *GetISCSIExtentsParams, reqEditors ...RequestEditorFn) (*GetISCSIExtentsResponse, error)

	// GetISCSIInitiators request
	GetISCSIInitiatorsWithResponse(ctx context.Context, params *GetISCSIInitiatorsParams, reqEditors ...RequestEditorFn) (*GetISCSIInitiatorsResponse, error)

	// GetDatasets request
	GetDatasetsWithResponse(ctx context.Context, params *GetDatasetsParams, reqEditors ...RequestEditorFn) (*GetDatasetsResponse, error)

	// CreateDataset request with any body
	CreateDatasetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatasetResponse, error)

	CreateDatasetWithResponse(ctx context.Context, body CreateDatasetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatasetResponse, error)

	// DeleteISCSIExtentWithResponse request
	DeleteISCSIExtentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteISCSIExtentResponse, error)

	// DeleteISCSITargetExtentWithResponse request
	DeleteISCSITargetExtentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteISCSITargetExtentResponse, error)

	// DeleteDataset request
	DeleteDatasetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDatasetResponse, error)

	// GetDataset request
	GetDatasetWithResponse(ctx context.Context, id string, params *GetDatasetParams, reqEditors ...RequestEditorFn) (*GetDatasetResponse, error)

	// UpdateDataset request with any body
	UpdateDatasetWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatasetResponse, error)

	UpdateDatasetWithResponse(ctx context.Context, id string, body UpdateDatasetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatasetResponse, error)

	// GetService request
	GetServiceWithResponse(ctx context.Context, id int, params *GetServiceParams, reqEditors ...RequestEditorFn) (*GetServiceResponse, error)

	// ListSharesNFS request
	ListSharesNFSWithResponse(ctx context.Context, params *ListSharesNFSParams, reqEditors ...RequestEditorFn) (*ListSharesNFSResponse, error)

	// CreateShareNFS request with any body
	CreateShareNFSWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateShareNFSResponse, error)

	CreateShareNFSWithResponse(ctx context.Context, body CreateShareNFSJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateShareNFSResponse, error)

	// RemoveShareNFS request
	RemoveShareNFSWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RemoveShareNFSResponse, error)

	// GetShareNFS request
	GetShareNFSWithResponse(ctx context.Context, id int, params *GetShareNFSParams, reqEditors ...RequestEditorFn) (*GetShareNFSResponse, error)

	// UpdateShareNFS request with any body
	UpdateShareNFSWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShareNFSResponse, error)

	UpdateShareNFSWithResponse(ctx context.Context, id int, body UpdateShareNFSJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShareNFSResponse, error)

	// ListSharesSMB request
	ListSharesSMBWithResponse(ctx context.Context, params *ListSharesSMBParams, reqEditors ...RequestEditorFn) (*ListSharesSMBResponse, error)

	// CreateShareSMB request with any body
	CreateShareSMBWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateShareSMBResponse, error)

	CreateShareSMBWithResponse(ctx context.Context, body CreateShareSMBJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateShareSMBResponse, error)

	// RemoveShareSMB request
	RemoveShareSMBWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RemoveShareSMBResponse, error)

	// GetShareSMB request
	GetShareSMBWithResponse(ctx context.Context, id int, params *GetShareSMBParams, reqEditors ...RequestEditorFn) (*GetShareSMBResponse, error)

	// UpdateShareSMB request with any body
	UpdateShareSMBWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShareSMBResponse, error)

	UpdateShareSMBWithResponse(ctx context.Context, id int, body UpdateShareSMBJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShareSMBResponse, error)

	// ListUsers request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUser request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUser request with any body
	DeleteUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	DeleteUserWithResponse(ctx context.Context, id int, body DeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, id int, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUser request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// GetUserShellChoices request with any body
	GetUserShellChoicesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUserShellChoicesResponse, error)

	GetUserShellChoicesWithResponse(ctx context.Context, body GetUserShellChoicesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUserShellChoicesResponse, error)

	// ListVMS request
	ListVMSWithResponse(ctx context.Context, params *ListVMSParams, reqEditors ...RequestEditorFn) (*ListVMSResponse, error)

	// GetVM request
	GetVMWithResponse(ctx context.Context, id int, params *GetVMParams, reqEditors ...RequestEditorFn) (*GetVMResponse, error)
}

type CreateCronJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CronJob
}

// Status returns HTTPResponse.Status
func (r CreateCronJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCronJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCronJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCronJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCronJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCronJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CronJob
}

// Status returns HTTPResponse.Status
func (r GetCronJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCronJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCronJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CronJob
}

// Status returns HTTPResponse.Status
func (r UpdateCronJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCronJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupResponse
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupResponse
}

// Status returns HTTPResponse.Status
func (r UpdateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkConfig
}

// Status returns HTTPResponse.Status
func (r GetNetworkConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkSummary
}

// Status returns HTTPResponse.Status
func (r GetNetworkSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
}

// Status returns HTTPResponse.Status
func (r GetServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSharesNFSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SharesNFSResponse
}

// Status returns HTTPResponse.Status
func (r ListSharesNFSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSharesNFSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateShareNFSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShareNFS
}

// Status returns HTTPResponse.Status
func (r CreateShareNFSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateShareNFSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveShareNFSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveShareNFSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveShareNFSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShareNFSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShareNFS
}

// Status returns HTTPResponse.Status
func (r GetShareNFSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShareNFSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShareNFSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShareNFS
}

// Status returns HTTPResponse.Status
func (r UpdateShareNFSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShareNFSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSharesSMBResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SharesSMBResponse
}

// Status returns HTTPResponse.Status
func (r ListSharesSMBResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSharesSMBResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateShareSMBResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShareSMB
}

// Status returns HTTPResponse.Status
func (r CreateShareSMBResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateShareSMBResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveShareSMBResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveShareSMBResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveShareSMBResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShareSMBResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShareSMB
}

// Status returns HTTPResponse.Status
func (r GetShareSMBResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShareSMBResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShareSMBResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShareSMB
}

// Status returns HTTPResponse.Status
func (r UpdateShareSMBResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShareSMBResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersResponse
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserShellChoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserShellChoices
}

// Status returns HTTPResponse.Status
func (r GetUserShellChoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserShellChoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVMSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMSResponse
}

// Status returns HTTPResponse.Status
func (r ListVMSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVMSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VM
}

// Status returns HTTPResponse.Status
func (r GetVMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateCronJobWithBodyWithResponse request with arbitrary body returning *CreateCronJobResponse
func (c *ClientWithResponses) CreateCronJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCronJobResponse, error) {
	rsp, err := c.CreateCronJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCronJobResponse(rsp)
}

func (c *ClientWithResponses) CreateCronJobWithResponse(ctx context.Context, body CreateCronJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCronJobResponse, error) {
	rsp, err := c.CreateCronJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCronJobResponse(rsp)
}

// DeleteCronJobWithResponse request returning *DeleteCronJobResponse
func (c *ClientWithResponses) DeleteCronJobWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteCronJobResponse, error) {
	rsp, err := c.DeleteCronJob(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCronJobResponse(rsp)
}

// GetCronJobWithResponse request returning *GetCronJobResponse
func (c *ClientWithResponses) GetCronJobWithResponse(ctx context.Context, id int, params *GetCronJobParams, reqEditors ...RequestEditorFn) (*GetCronJobResponse, error) {
	rsp, err := c.GetCronJob(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCronJobResponse(rsp)
}

// UpdateCronJobWithBodyWithResponse request with arbitrary body returning *UpdateCronJobResponse
func (c *ClientWithResponses) UpdateCronJobWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCronJobResponse, error) {
	rsp, err := c.UpdateCronJobWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCronJobResponse(rsp)
}

func (c *ClientWithResponses) UpdateCronJobWithResponse(ctx context.Context, id int, body UpdateCronJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCronJobResponse, error) {
	rsp, err := c.UpdateCronJob(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCronJobResponse(rsp)
}

// ListGroupsWithResponse request returning *ListGroupsResponse
func (c *ClientWithResponses) ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error) {
	rsp, err := c.ListGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithBodyWithResponse request with arbitrary body returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroupWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, id int, body DeleteGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, id int, params *GetGroupParams, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// UpdateGroupWithBodyWithResponse request with arbitrary body returning *UpdateGroupResponse
func (c *ClientWithResponses) UpdateGroupWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroupWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupWithResponse(ctx context.Context, id int, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroup(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

// GetNetworkConfigurationWithResponse request returning *GetNetworkConfigurationResponse
func (c *ClientWithResponses) GetNetworkConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNetworkConfigurationResponse, error) {
	rsp, err := c.GetNetworkConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkConfigurationResponse(rsp)
}

// GetNetworkSummaryWithResponse request returning *GetNetworkSummaryResponse
func (c *ClientWithResponses) GetNetworkSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNetworkSummaryResponse, error) {
	rsp, err := c.GetNetworkSummary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkSummaryResponse(rsp)
}

// GetServiceWithResponse request returning *GetServiceResponse
func (c *ClientWithResponses) GetServiceWithResponse(ctx context.Context, id int, params *GetServiceParams, reqEditors ...RequestEditorFn) (*GetServiceResponse, error) {
	rsp, err := c.GetService(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceResponse(rsp)
}

// ListSharesNFSWithResponse request returning *ListSharesNFSResponse
func (c *ClientWithResponses) ListSharesNFSWithResponse(ctx context.Context, params *ListSharesNFSParams, reqEditors ...RequestEditorFn) (*ListSharesNFSResponse, error) {
	rsp, err := c.ListSharesNFS(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSharesNFSResponse(rsp)
}

// CreateShareNFSWithBodyWithResponse request with arbitrary body returning *CreateShareNFSResponse
func (c *ClientWithResponses) CreateShareNFSWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateShareNFSResponse, error) {
	rsp, err := c.CreateShareNFSWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateShareNFSResponse(rsp)
}

func (c *ClientWithResponses) CreateShareNFSWithResponse(ctx context.Context, body CreateShareNFSJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateShareNFSResponse, error) {
	rsp, err := c.CreateShareNFS(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateShareNFSResponse(rsp)
}

// RemoveShareNFSWithResponse request returning *RemoveShareNFSResponse
func (c *ClientWithResponses) RemoveShareNFSWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RemoveShareNFSResponse, error) {
	rsp, err := c.RemoveShareNFS(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveShareNFSResponse(rsp)
}

// GetShareNFSWithResponse request returning *GetShareNFSResponse
func (c *ClientWithResponses) GetShareNFSWithResponse(ctx context.Context, id int, params *GetShareNFSParams, reqEditors ...RequestEditorFn) (*GetShareNFSResponse, error) {
	rsp, err := c.GetShareNFS(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShareNFSResponse(rsp)
}

// UpdateShareNFSWithBodyWithResponse request with arbitrary body returning *UpdateShareNFSResponse
func (c *ClientWithResponses) UpdateShareNFSWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShareNFSResponse, error) {
	rsp, err := c.UpdateShareNFSWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShareNFSResponse(rsp)
}

func (c *ClientWithResponses) UpdateShareNFSWithResponse(ctx context.Context, id int, body UpdateShareNFSJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShareNFSResponse, error) {
	rsp, err := c.UpdateShareNFS(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShareNFSResponse(rsp)
}

// ListSharesSMBWithResponse request returning *ListSharesSMBResponse
func (c *ClientWithResponses) ListSharesSMBWithResponse(ctx context.Context, params *ListSharesSMBParams, reqEditors ...RequestEditorFn) (*ListSharesSMBResponse, error) {
	rsp, err := c.ListSharesSMB(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSharesSMBResponse(rsp)
}

// CreateShareSMBWithBodyWithResponse request with arbitrary body returning *CreateShareSMBResponse
func (c *ClientWithResponses) CreateShareSMBWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateShareSMBResponse, error) {
	rsp, err := c.CreateShareSMBWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateShareSMBResponse(rsp)
}

func (c *ClientWithResponses) CreateShareSMBWithResponse(ctx context.Context, body CreateShareSMBJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateShareSMBResponse, error) {
	rsp, err := c.CreateShareSMB(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateShareSMBResponse(rsp)
}

// RemoveShareSMBWithResponse request returning *RemoveShareSMBResponse
func (c *ClientWithResponses) RemoveShareSMBWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RemoveShareSMBResponse, error) {
	rsp, err := c.RemoveShareSMB(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveShareSMBResponse(rsp)
}

// GetShareSMBWithResponse request returning *GetShareSMBResponse
func (c *ClientWithResponses) GetShareSMBWithResponse(ctx context.Context, id int, params *GetShareSMBParams, reqEditors ...RequestEditorFn) (*GetShareSMBResponse, error) {
	rsp, err := c.GetShareSMB(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShareSMBResponse(rsp)
}

// UpdateShareSMBWithBodyWithResponse request with arbitrary body returning *UpdateShareSMBResponse
func (c *ClientWithResponses) UpdateShareSMBWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShareSMBResponse, error) {
	rsp, err := c.UpdateShareSMBWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShareSMBResponse(rsp)
}

func (c *ClientWithResponses) UpdateShareSMBWithResponse(ctx context.Context, id int, body UpdateShareSMBJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShareSMBResponse, error) {
	rsp, err := c.UpdateShareSMB(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateShareSMBResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithBodyWithResponse request with arbitrary body returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUserWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, id int, body DeleteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, id int, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// GetUserShellChoicesWithBodyWithResponse request with arbitrary body returning *GetUserShellChoicesResponse
func (c *ClientWithResponses) GetUserShellChoicesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUserShellChoicesResponse, error) {
	rsp, err := c.GetUserShellChoicesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserShellChoicesResponse(rsp)
}

func (c *ClientWithResponses) GetUserShellChoicesWithResponse(ctx context.Context, body GetUserShellChoicesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUserShellChoicesResponse, error) {
	rsp, err := c.GetUserShellChoices(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserShellChoicesResponse(rsp)
}

// ListVMSWithResponse request returning *ListVMSResponse
func (c *ClientWithResponses) ListVMSWithResponse(ctx context.Context, params *ListVMSParams, reqEditors ...RequestEditorFn) (*ListVMSResponse, error) {
	rsp, err := c.ListVMS(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVMSResponse(rsp)
}

// GetVMWithResponse request returning *GetVMResponse
func (c *ClientWithResponses) GetVMWithResponse(ctx context.Context, id int, params *GetVMParams, reqEditors ...RequestEditorFn) (*GetVMResponse, error) {
	rsp, err := c.GetVM(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVMResponse(rsp)
}

// ParseCreateCronJobResponse parses an HTTP response from a CreateCronJobWithResponse call
func ParseCreateCronJobResponse(rsp *http.Response) (*CreateCronJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCronJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest CronJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCronJobResponse parses an HTTP response from a DeleteCronJobWithResponse call
func ParseDeleteCronJobResponse(rsp *http.Response) (*DeleteCronJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCronJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCronJobResponse parses an HTTP response from a GetCronJobWithResponse call
func ParseGetCronJobResponse(rsp *http.Response) (*GetCronJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCronJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest CronJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCronJobResponse parses an HTTP response from a UpdateCronJobWithResponse call
func ParseUpdateCronJobResponse(rsp *http.Response) (*UpdateCronJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCronJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest CronJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGroupsResponse parses an HTTP response from a ListGroupsWithResponse call
func ParseListGroupsResponse(rsp *http.Response) (*ListGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest GroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateGroupResponse parses an HTTP response from a UpdateGroupWithResponse call
func ParseUpdateGroupResponse(rsp *http.Response) (*UpdateGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest GroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNetworkConfigurationResponse parses an HTTP response from a GetNetworkConfigurationWithResponse call
func ParseGetNetworkConfigurationResponse(rsp *http.Response) (*GetNetworkConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest NetworkConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNetworkSummaryResponse parses an HTTP response from a GetNetworkSummaryWithResponse call
func ParseGetNetworkSummaryResponse(rsp *http.Response) (*GetNetworkSummaryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest NetworkSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceResponse parses an HTTP response from a GetServiceWithResponse call
func ParseGetServiceResponse(rsp *http.Response) (*GetServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSharesNFSResponse parses an HTTP response from a ListSharesNFSWithResponse call
func ParseListSharesNFSResponse(rsp *http.Response) (*ListSharesNFSResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSharesNFSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest SharesNFSResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateShareNFSResponse parses an HTTP response from a CreateShareNFSWithResponse call
func ParseCreateShareNFSResponse(rsp *http.Response) (*CreateShareNFSResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateShareNFSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest ShareNFS
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveShareNFSResponse parses an HTTP response from a RemoveShareNFSWithResponse call
func ParseRemoveShareNFSResponse(rsp *http.Response) (*RemoveShareNFSResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveShareNFSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetShareNFSResponse parses an HTTP response from a GetShareNFSWithResponse call
func ParseGetShareNFSResponse(rsp *http.Response) (*GetShareNFSResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShareNFSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest ShareNFS
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateShareNFSResponse parses an HTTP response from a UpdateShareNFSWithResponse call
func ParseUpdateShareNFSResponse(rsp *http.Response) (*UpdateShareNFSResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShareNFSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest ShareNFS
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSharesSMBResponse parses an HTTP response from a ListSharesSMBWithResponse call
func ParseListSharesSMBResponse(rsp *http.Response) (*ListSharesSMBResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSharesSMBResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest SharesSMBResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateShareSMBResponse parses an HTTP response from a CreateShareSMBWithResponse call
func ParseCreateShareSMBResponse(rsp *http.Response) (*CreateShareSMBResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateShareSMBResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest ShareSMB
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveShareSMBResponse parses an HTTP response from a RemoveShareSMBWithResponse call
func ParseRemoveShareSMBResponse(rsp *http.Response) (*RemoveShareSMBResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveShareSMBResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetShareSMBResponse parses an HTTP response from a GetShareSMBWithResponse call
func ParseGetShareSMBResponse(rsp *http.Response) (*GetShareSMBResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShareSMBResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest ShareSMB
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateShareSMBResponse parses an HTTP response from a UpdateShareSMBWithResponse call
func ParseUpdateShareSMBResponse(rsp *http.Response) (*UpdateShareSMBResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateShareSMBResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest ShareSMB
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest UsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserShellChoicesResponse parses an HTTP response from a GetUserShellChoicesWithResponse call
func ParseGetUserShellChoicesResponse(rsp *http.Response) (*GetUserShellChoicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserShellChoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest UserShellChoices
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVMSResponse parses an HTTP response from a ListVMSWithResponse call
func ParseListVMSResponse(rsp *http.Response) (*ListVMSResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVMSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest VMSResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVMResponse parses an HTTP response from a GetVMWithResponse call
func ParseGetVMResponse(rsp *http.Response) (*GetVMResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 200:
		var dest VM
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
