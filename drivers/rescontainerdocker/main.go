package rescontainerdocker

import (
	"context"
	"encoding/json"
	"fmt"
	"os/exec"
	"strings"
	"time"

	"github.com/cpuguy83/go-docker"
	"github.com/cpuguy83/go-docker/container"
	"github.com/cpuguy83/go-docker/container/containerapi"
	"github.com/cpuguy83/go-docker/errdefs"
	"github.com/cpuguy83/go-docker/image"
	"github.com/google/uuid"
	"github.com/kballard/go-shellquote"
	"opensvc.com/opensvc/core/actionrollback"
	"opensvc.com/opensvc/core/drivergroup"
	"opensvc.com/opensvc/core/keywords"
	"opensvc.com/opensvc/core/manifest"
	"opensvc.com/opensvc/core/path"
	"opensvc.com/opensvc/core/provisioned"
	"opensvc.com/opensvc/core/resource"
	"opensvc.com/opensvc/core/resourceid"
	"opensvc.com/opensvc/core/status"
	"opensvc.com/opensvc/drivers/rescontainer"
	"opensvc.com/opensvc/util/converters"
	"opensvc.com/opensvc/util/envprovider"
	"opensvc.com/opensvc/util/pg"
	"opensvc.com/opensvc/util/stringslice"
)

const (
	driverGroup = drivergroup.Container
	driverName  = "docker"

	AlwaysPolicy = "always"
	OncePolicy   = "once"
)

type (
	T struct {
		resource.T
		PG              pg.Config      `json:"pg"`
		Path            path.T         `json:"path"`
		ObjectID        uuid.UUID      `json:"object_id"`
		SCSIReserv      bool           `json:"scsireserv"`
		PromoteRW       bool           `json:"promote_rw"`
		NoPreemptAbort  bool           `json:"NoPreemptAbort"`
		OsvcRootPath    string         `json:"osvc_root_path"`
		GuestOS         string         `json:"guest_os"`
		Name            string         `json:"name"`
		Hostname        string         `json:"hostname"`
		Image           string         `json:"image"`
		ImagePullPolicy string         `json:"image_pull_policy"`
		CWD             string         `json:"cwd"`
		Command         []string       `json:"command"`
		RunArgs         []string       `json:"run_args"`
		Entrypoint      []string       `json:"entrypoint"`
		Detach          bool           `json:"detach"`
		Remove          bool           `json:"remove"`
		Privileged      bool           `json:"privileged"`
		Interactive     bool           `json:"interactive"`
		TTY             bool           `json:"tty"`
		VolumeMounts    []string       `json:"volume_mounts"`
		Env             []string       `json:"environment"`
		SecretsEnv      []string       `json:"secrets_environment"`
		ConfigsEnv      []string       `json:"configs_environment"`
		Devices         []string       `json:"devices"`
		NetNS           string         `json:"netns"`
		UserNS          string         `json:"userns"`
		PIDNS           string         `json:"pidns"`
		IPCNS           string         `json:"ipcns"`
		UTSNS           string         `json:"utsns"`
		RegistryCreds   string         `json:"registry_creds"`
		PullTimeout     *time.Duration `json:"pull_timeout"`
		StartTimeout    *time.Duration `json:"start_timeout"`
		StopTimeout     *time.Duration `json:"stop_timeout"`
	}

	containerNamer interface {
		ContainerName() string
	}
)

var (
	// Allocate a single client socket for all container.docker resources
	// Get/Init it via cli()
	clientCache *docker.Client
	imageCache  = make(map[string]*image.Image)
)

func cli() *docker.Client {
	if clientCache != nil {
		return clientCache
	}
	clientCache = docker.NewClient()
	return clientCache
}

func init() {
	resource.Register(driverGroup, driverName, New)
	resource.Register(driverGroup, "oci", New)
}

func capabilitiesScanner() ([]string, error) {
	l := make([]string, 0)
	if _, err := exec.LookPath("docker"); err == nil {
		return l, nil
	}
	l = append(l, "drivers.resource.container.docker")
	l = append(l, "drivers.resource.container.docker.registry_creds")
	l = append(l, "drivers.resource.container.docker.signal")
	return l, nil
}

func New() resource.Driver {
	t := &T{}
	return t
}

// Manifest exposes to the core the input expected by the driver.
func (t T) Manifest() *manifest.T {
	m := manifest.New(driverGroup, driverName, t)
	m.AddContext([]manifest.Context{
		{
			Key:  "path",
			Attr: "Path",
			Ref:  "object.path",
		},
		{
			Key:  "object_id",
			Attr: "ObjectID",
			Ref:  "object.id",
		},
	}...)
	m.AddKeyword([]keywords.Keyword{
		{
			Option:      "name",
			Attr:        "Name",
			Scopable:    true,
			DefaultText: "<autogenerated>",
			Text:        "The name to assign to the container on docker run. If none is specified a ``<namespace>..<name>.container.<rid idx>`` name is automatically assigned.",
			Example:     "osvcprd..rundeck.container.db",
		},
		{
			Option:   "hostname",
			Attr:     "Hostname",
			Scopable: true,
			Example:  "nginx1",
			Text:     "Set the container hostname. If not set, a unique id is used.",
		},
		{
			Option:   "image",
			Attr:     "Image",
			Aliases:  []string{"run_image"},
			Scopable: true,
			Required: true,
			Example:  "google/pause",
			Text:     "The docker image pull, and run the container with.",
		},
		{
			Option:     "image_pull_policy",
			Attr:       "ImagePullPolicy",
			Scopable:   true,
			Candidates: []string{"once", "always"},
			Example:    "once",
			Text:       "The docker image pull policy. ``always`` pull upon each container start, ``once`` pull if not already pulled (default).",
		},
		{
			Option:   "cwd",
			Attr:     "CWD",
			Scopable: true,
			Example:  "/opt/foo",
			Text:     "The current working directory set for the executed command.",
		},
		{
			Option:    "command",
			Attr:      "Command",
			Aliases:   []string{"run_command"},
			Scopable:  true,
			Converter: converters.Shlex,
			Example:   "/opt/tomcat/bin/catalina.sh",
			Text:      "The command to execute in the docker container on run.",
		},
		{
			Option:    "run_args",
			Attr:      "RunArgs",
			Scopable:  true,
			Converter: converters.Shlex,
			Example:   "-v /opt/docker.opensvc.com/vol1:/vol1:rw -p 37.59.71.25:8080:8080",
			Text:      "Extra arguments to pass to the docker run command, like volume and port mappings.",
		},
		{
			Option:    "entrypoint",
			Attr:      "Entrypoint",
			Scopable:  true,
			Converter: converters.Shlex,
			Example:   "/bin/sh",
			Text:      "The script or binary executed in the container. Args must be set in :kw:`command`.",
		},
		{
			Option:    "detach",
			Attr:      "Detach",
			Scopable:  true,
			Converter: converters.Bool,
			Default:   "true",
			Text:      "Run container in background. Set to ``false`` only for init containers, alongside :kw:`start_timeout` and the :c-tag:`nostatus` tag.",
		},
		{
			Option:    "rm",
			Attr:      "Remove",
			Scopable:  true,
			Converter: converters.Bool,
			Example:   "false",
			Text:      "If set to ``true``, add :opt:`--rm` to the docker run args and make sure the instance is removed on resource stop.",
		},
		{
			Option:    "privileged",
			Attr:      "Privileged",
			Scopable:  true,
			Converter: converters.Bool,
			Text:      "Give extended privileges to the container.",
		},
		{
			Option:    "interactive",
			Attr:      "Interactive",
			Scopable:  true,
			Converter: converters.Bool,
			Text:      "Keep stdin open even if not attached. To use if the container entrypoint is a shell.",
		},
		{
			Option:    "tty",
			Attr:      "TTY",
			Scopable:  true,
			Converter: converters.Bool,
			Text:      "Allocate a pseudo-tty.",
		},
		{
			Option:    "volume_mounts",
			Attr:      "VolumeMounts",
			Scopable:  true,
			Converter: converters.Shlex,
			Text:      "The whitespace separated list of ``<volume name|local dir>:<containerized mount path>:<mount options>``. When the source is a local dir, the default <mount option> is rw. When the source is a volume name, the default <mount option> is taken from volume access.",
			Example:   "myvol1:/vol1 myvol2:/vol2:rw /localdir:/data:ro",
		},
		{
			Option:    "environment",
			Attr:      "Env",
			Scopable:  true,
			Converter: converters.Shlex,
			Text:      "A whitespace separated list of ``<var>=<secret name>/<key path>``. A shell expression spliter is applied, so double quotes can be around ``<secret name>/<key path>`` only or whole ``<var>=<secret name>/<key path>``. Variables are uppercased.",
			Example:   "KEY=cert1/server.key PASSWORD=db/password",
		},
		{
			Option:    "configs_environment",
			Attr:      "ConfigsEnv",
			Scopable:  true,
			Converter: converters.Shlex,
			Text:      "A whitespace separated list of ``<var>=<config name>/<key path>``. A shell expression spliter is applied, so double quotes can be around ``<config name>/<key path>`` only or whole ``<var>=<config name>/<key path>``. Variables are uppercased.",
			Example:   "CRT=cert1/server.crt PEM=cert1/server.pem",
		},
		{
			Option:    "devices",
			Attr:      "Devices",
			Scopable:  true,
			Converter: converters.Shlex,
			Text:      "The whitespace separated list of ``<host devpath>:<containerized devpath>``, specifying the host devices the container should have access to.",
			Example:   "myvol1:/dev/xvda myvol2:/dev/xvdb",
		},
		{
			Option:   "netns",
			Attr:     "NetNS",
			Aliases:  []string{"net"},
			Scopable: true,
			Example:  "container#0",
			Text:     "Sets the :cmd:`docker run --net` argument. The default is ``none`` if :opt:`--net` is not specified in :kw:`run_args`, meaning the container will have a private netns other containers can share. A :c-res:`ip.netns` or :c-res:`ip.cni` resource can configure an ip address in this container. A container with ``netns=container#0`` will share the container#0 netns. In this case agent format a :opt:`--net=container:<name of container#0 docker instance>`. ``netns=host`` shares the host netns.",
		},
		{
			Option:   "userns",
			Attr:     "UserNS",
			Scopable: true,
			Example:  "container#0",
			Text:     "Sets the :cmd:`docker run --userns` argument. If not set, the container will have a private userns other containers can share. A container with ``userns=host`` will share the host's userns.",
		},
		{
			Option:   "pidns",
			Attr:     "PIDNS",
			Scopable: true,
			Example:  "container#0",
			Text:     "Sets the :cmd:`docker run --pid` argument. If not set, the container will have a private pidns other containers can share. Usually a pidns sharer will run a google/pause image to reap zombies. A container with ``pidns=container#0`` will share the container#0 pidns. In this case agent format a :opt:`--pid=container:<name of container#0 docker instance>`. Use ``pidns=host`` to share the host's pidns.",
		},
		{
			Option:   "ipcns",
			Attr:     "IPCNS",
			Scopable: true,
			Example:  "container#0",
			Text:     "Sets the :cmd:`docker run --ipc` argument. If not set, the docker daemon's default value is used. ``ipcns=none`` does not mount /dev/shm. ``ipcns=private`` creates a ipcns other containers can not share. ``ipcns=shareable`` creates a netns other containers can share. ``ipcns=container#0`` will share the container#0 ipcns.",
		},
		{
			Option:     "utsns",
			Attr:       "UTSNS",
			Scopable:   true,
			Candidates: []string{"", "host"},
			Example:    "container#0",
			Text:       "Sets the :cmd:`docker run --uts` argument. If not set, the container will have a private utsns. A container with ``utsns=host`` will share the host's hostname.",
		},
		{
			Option:   "registry_creds",
			Attr:     "RegistryCreds",
			Scopable: true,
			Example:  "creds-registry-opensvc-com",
			Text:     "The name of a secret in the same namespace having a config.json key which value is used to login to the container image registry. If not specified, the node-level registry credential store is used.",
		},
		{
			Option:    "pull_timeout",
			Attr:      "PullTimeout",
			Scopable:  true,
			Converter: converters.Duration,
			Text:      "Wait for <duration> before declaring the container action a failure.",
			Example:   "2m",
			Default:   "2m",
		},
		{
			Option:    "start_timeout",
			Attr:      "StartTimeout",
			Scopable:  true,
			Converter: converters.Duration,
			Text:      "Wait for <duration> before declaring the container action a failure.",
			Example:   "5s",
			Default:   "1m5s",
		},
		{
			Option:    "stop_timeout",
			Attr:      "StopTimeout",
			Scopable:  true,
			Converter: converters.Duration,
			Text:      "Wait for <duration> before declaring the container action a failure.",
			Example:   "2m",
			Default:   "2m30s",
		},
		{
			Option:    "secrets_environment",
			Attr:      "SecretsEnv",
			Scopable:  true,
			Converter: converters.Shlex,
			Text: "A whitespace separated list of ``<var>=<sec name>/<key path>`` or ``<sec name>/<key matcher>``." +
				" If secret object or secret key doesn't exist then start, stop, ... actions on resource will fail" +
				" with non 0 exit code." +
				" A shell expression splitter is applied, so double quotes can be around ``<secret name>/<key path>``" +
				" only or whole ``<var>=<secret name>/<key path>``.",
			Example: "``CRT=cert1/server.pem sec1/*`` to create following env vars CRT=< <ns>/sec/cert1 decoded" +
				" value of key server.pem> <key1>=< <ns>/sec/sec1 decoded value of <key1> ...",
		},
		{
			Option:    "configs_environment",
			Attr:      "ConfigsEnv",
			Scopable:  true,
			Converter: converters.Shlex,
			Text: "The whitespace separated list of ``<var>=<cfg name>/<key path>`` or ``<cfg name>/<key matcher>``." +
				" If config object or config key doesn't exist then start, stop, ... actions on resource will fail" +
				" with non 0 exit code." +
				" A shell expression splitter is applied, so double quotes can be around ``<config name>/<key path>``" +
				" only or whole ``<var>=<config name>/<key path>``.",
			Example: "``PORT=http/port webapp/app1* {name}/* {name}-debug/settings``",
		},
		rescontainer.KWSCSIReserv,
		rescontainer.KWPromoteRW,
		rescontainer.KWNoPreemptAbort,
		rescontainer.KWOsvcRootPath,
		rescontainer.KWGuestOS,
	}...)
	return m
}

func (t T) pull(ctx context.Context) error {
	return fmt.Errorf("TODO: pull()")
}

func (t T) labels() (map[string]string, error) {
	data := make(map[string]string)
	data["com.opensvc.id"] = t.containerLabelID()
	data["com.opensvc.path"] = t.Path.String()
	data["com.opensvc.namespace"] = t.Path.Namespace
	data["com.opensvc.kind"] = t.Path.Kind.String()
	data["com.opensvc.name"] = t.Path.Name
	data["com.opensvc.rid"] = t.ResourceID.String()
	return data, nil
}

func (t T) devices() ([]containerapi.DeviceMapping, error) {
	data := make([]containerapi.DeviceMapping, 0)
	for _, s := range t.Devices {
		l := strings.Split(s, ":")
		dm := containerapi.DeviceMapping{}
		n := len(l)
		switch {
		case n <= 3:
			dm.PathOnHost = l[0]
			dm.PathInContainer = l[1]
			fallthrough
		case n == 3:
			dm.CgroupPermissions = l[2]
		}
		data = append(data, dm)
	}
	return data, nil
}

func (t T) Start(ctx context.Context) error {
	cs := cli().ContainerService()
	name := t.ContainerName()
	inspect, err := cs.Inspect(ctx, name)
	if err == nil {
		if inspect.State.Running {
			t.Log().Info().Msg("already running")
			return nil
		} else {
			if t.Remove {
				t.Log().Info().Str("name", name).Msgf("remove leftover")
				if err := cs.Remove(ctx, name); err != nil {
					return err
				}
				if t.ImagePullPolicy == AlwaysPolicy {
					t.pull(ctx)
				}
				c, err := t.create(ctx)
				if err != nil {
					return err
				}
				return c.Start(ctx)
			} else {
				t.Log().Info().Str("name", name).Str("id", inspect.ID).Msgf("start")
				return cs.NewContainer(ctx, inspect.ID).Start(ctx)
			}
		}
	} else {
		if t.ImagePullPolicy == AlwaysPolicy {
			t.pull(ctx)
		}
		c, err := t.create(ctx)
		if err != nil {
			return err
		}
		return c.Start(ctx)
	}
	return nil
}

func (t T) create(ctx context.Context) (*container.Container, error) {
	var (
		env     []string
		command []string
		labels  map[string]string
		devices []containerapi.DeviceMapping
		err     error
	)
	if env, err = t.env(); err != nil {
		return nil, err
	}
	if labels, err = t.labels(); err != nil {
		return nil, err
	}
	if devices, err = t.devices(); err != nil {
		return nil, err
	}
	if command, err = t.command(); err != nil {
		return nil, err
	}

	config := containerapi.Config{
		Hostname:   t.Hostname,
		Tty:        t.TTY,
		Env:        env,
		Cmd:        command,
		Entrypoint: t.Entrypoint,
		Image:      t.Image,
		WorkingDir: t.CWD,
		Labels:     labels,
	}

	hostConfig := containerapi.HostConfig{}
	hostConfig.Privileged = t.Privileged
	hostConfig.AutoRemove = t.Remove
	hostConfig.Cgroup = t.PG.ID
	hostConfig.Devices = devices
	// DNS go here

	name := t.ContainerName()

	configObf := config
	if configObf.Env, err = t.obfuscatedEnv(); err != nil {
		return nil, err
	}
	configStr, _ := json.Marshal(configObf)
	hostConfigStr, _ := json.Marshal(hostConfig)

	t.Log().Info().
		Str("name", name).
		Bytes("config", configStr).
		Bytes("hostConfig", hostConfigStr).
		Msgf("create")
	c, err := cli().ContainerService().Create(
		ctx,
		container.WithCreateName(name),
		container.WithCreateConfig(config),
		container.WithCreateHostConfig(hostConfig),
	)
	if err != nil {
		return nil, err
	}
	actionrollback.Register(ctx, func() error {
		var xc int
		if err := c.Stop(ctx); err != nil {
			return err
		}
		if x, err := c.Wait(ctx, container.WithWaitCondition(container.WaitConditionNotRunning)); err != nil {
			return err
		} else {
			xc = x.ExitCode()
		}
		t.Log().Info().Msgf("exited with code %d", xc)
		return nil
	})
	return c, nil
}

func (t T) Stop(ctx context.Context) error {
	name := t.ContainerName()
	inspect, err := cli().ContainerService().Inspect(ctx, name)
	c := cli().ContainerService().NewContainer(ctx, inspect.ID)
	if (err == nil && !inspect.State.Running) || errdefs.IsNotFound(err) {
		t.Log().Info().Str("name", name).Msg("already stopped")
	} else {
		t.Log().Info().Str("name", name).Str("id", inspect.ID).Msgf("stop")
		if err := c.Stop(ctx); err != nil {
			return err
		}
	}
	if t.Remove && !errdefs.IsNotFound(err) {
		if !inspect.HostConfig.AutoRemove {
			t.Log().Info().Str("name", name).Msgf("remove")
			return cli().ContainerService().Remove(ctx, name)
		}
		xs, err := c.Wait(ctx, container.WithWaitCondition(container.WaitConditionRemoved))
		if err != nil {
			return err
		}
		t.Log().Debug().Msgf("wait removed condition ended with exit code %d", xs.ExitCode())
	} else {
		t.Log().Info().Msg("already removed")
	}
	return nil
}

func (t T) warnAttrDiff(attr, current, target string) {
	t.StatusLog().Warn("%s is %s, should be %s", attr, current, target)
}

func (t *T) Status(ctx context.Context) status.T {
	if !t.Detach {
		return status.NotApplicable
	}
	if err := t.isDockerdPinging(ctx); err != nil {
		t.Log().Debug().Err(err).Msg("ping")
		t.StatusLog().Info("docker daemon is not running")
		return status.Down
	}
	inspect, err := cli().ContainerService().Inspect(ctx, t.ContainerName())
	switch {
	case err == nil:
	case errdefs.IsNotFound(err):
		return status.Down
	default:
		t.StatusLog().Error("inspect: %s", err)
		return status.Down
	}
	if t.Hostname != "" && inspect.Config.Hostname != t.Hostname {
		t.warnAttrDiff("hostname", inspect.Config.Hostname, t.Hostname)
	}
	if inspect.Config.OpenStdin != t.Interactive {
		t.warnAttrDiff("interactive", fmt.Sprint(inspect.Config.OpenStdin), fmt.Sprint(t.Interactive))
	}
	if len(t.Entrypoint) > 0 && !stringslice.Equal(inspect.Config.Entrypoint, t.Entrypoint) {
		t.warnAttrDiff("entrypoint", shellquote.Join(inspect.Config.Entrypoint...), shellquote.Join(t.Entrypoint...))
	}
	if inspect.Config.Tty != t.TTY {
		t.warnAttrDiff("tty", fmt.Sprint(inspect.Config.Tty), fmt.Sprint(t.TTY))
	}
	if inspect.HostConfig.Privileged != t.Privileged {
		t.warnAttrDiff("privileged", fmt.Sprint(inspect.HostConfig.Privileged), fmt.Sprint(t.Privileged))
	}
	t.statusInspectNS(ctx, "netns", inspect.HostConfig.NetworkMode, t.NetNS)
	t.statusInspectNS(ctx, "pidns", inspect.HostConfig.PidMode, t.PIDNS)
	t.statusInspectNS(ctx, "ipcns", inspect.HostConfig.IpcMode, t.IPCNS)
	t.statusInspectNS(ctx, "utsns", inspect.HostConfig.UTSMode, t.UTSNS)
	t.statusInspectNS(ctx, "userns", inspect.HostConfig.UsernsMode, t.UserNS)
	if !inspect.State.Running {
		return status.Down
	}
	return status.Up
}

func (t T) statusInspectNS(ctx context.Context, attr, current, target string) {
	rid, err := resourceid.Parse(target)
	if err != nil {
		// target value is not a rid ("host", "none" for ex)
		//  => simple string comparison
		if current != target {
			t.warnAttrDiff(attr, current, target)
		}
		return
	}
	r := t.GetObjectDriver().ResourceByID(rid.String())
	if r == nil {
		t.StatusLog().Warn("%s: %s resource not found", attr, target)
	}
	if i, ok := r.(containerNamer); ok {
		name := i.ContainerName()
		switch {
		case "container:"+name == current:
			t.Log().Debug().Msgf("valid %s cross-resource reference to %s: %s", attr, target, current)
		case "container:"+containerID(ctx, name) == current:
			t.Log().Debug().Msgf("valid %s cross-resource reference to %s: %s", attr, target, current)
		default:
			t.warnAttrDiff(attr, current, target)
		}
	} else {
		fmt.Println("not a containerNamer", r)
	}
}

func (t T) isDockerdPinging(ctx context.Context) error {
	_, err := cli().SystemService().Ping(ctx)
	if err != nil {
		return err
	}
	return nil
}

func (t T) Label() string {
	return t.Image
}

func (t T) Provision(ctx context.Context) error {
	return nil
}

func (t T) Unprovision(ctx context.Context) error {
	return nil
}

func (t T) Provisioned() (provisioned.T, error) {
	return provisioned.NotApplicable, nil
}

func containerID(ctx context.Context, name string) string {
	inspect, err := cli().ContainerService().Inspect(ctx, name)
	if err != nil {
		return ""
	}
	return inspect.ID
}

// ContainerName formats a docker container name
func (t T) ContainerName() string {
	if t.Name != "" {
		return t.Name
	}
	s := ""
	if t.Path.Namespace != "" {
		s = t.Path.Namespace + ".."
	}
	s = s + t.Path.Name + "." + strings.ReplaceAll(t.ResourceID.String(), "#", ".")
	return s
}

func (t T) containerLabelID() string {
	return fmt.Sprintf("%s.%s", t.ObjectID, t.ResourceID.String())
}

func (t T) command() ([]string, error) {
	if len(t.Command) > 0 {
		return t.Command, nil
	}
	img, err := t.image()
	if err != nil {
		return nil, err
	}
	inspect, err := img.Inspect(context.Background())
	if err != nil {
		return nil, err
	}
	if len(inspect.Config.Cmd) > 0 {
		return inspect.Config.Cmd, nil
	}
	return inspect.Config.Entrypoint, nil
}

func (t T) image() (*image.Image, error) {
	if img, ok := imageCache[t.Image]; ok {
		return img, nil
	}
	img, err := cli().ImageService().FindImage(context.Background(), t.Image)
	if err != nil {
		return nil, err
	}
	imageCache[t.Image] = img
	return img, nil
}

func (t T) env() (env []string, err error) {
	return t.obfuscatableEnv(false)
}

func (t T) obfuscatedEnv() (env []string, err error) {
	return t.obfuscatableEnv(true)
}

func (t T) obfuscatableEnv(obfuscate bool) (env []string, err error) {
	var tempEnv []string
	env = []string{
		"OPENSVC_RID=" + t.RID(),
		"OPENSVC_NAME=" + t.Path.String(),
		"OPENSVC_KIND=" + t.Path.Kind.String(),
		"OPENSVC_ID=" + t.ObjectID.String(),
		"OPENSVC_NAMESPACE=" + t.Path.Namespace,
	}
	if len(t.Env) > 0 {
		env = append(env, t.Env...)
	}
	if tempEnv, err = envprovider.From(t.ConfigsEnv, t.Path.Namespace, "cfg"); err != nil {
		return nil, err
	}
	env = append(env, tempEnv...)
	if tempEnv, err = envprovider.From(t.SecretsEnv, t.Path.Namespace, "sec"); err != nil {
		return nil, err
	}
	if obfuscate {
		for i, s := range tempEnv {
			l := strings.SplitN(s, "=", 2)
			if len(l) != 2 {
				continue
			}
			tempEnv[i] = l[0] + "=xxx"
		}
	}
	env = append(env, tempEnv...)
	return env, nil
}
